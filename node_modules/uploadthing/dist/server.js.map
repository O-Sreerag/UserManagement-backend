{"version":3,"sources":["../src/server.ts","../package.json","../src/constants.ts","../src/internal/error-formatter.ts","../src/internal/handler.ts","../src/internal/dev-hook.ts","../src/internal/logger.ts","../src/internal/get-full-api-url.ts","../src/internal/parser.ts","../src/internal/types.ts","../src/internal/incompat-node-guard.ts","../src/internal/upload-builder.ts","../src/sdk/index.ts","../src/sdk/utils.ts","../src/internal/multi-part.ts","../src/internal/s3-error-parser.ts"],"sourcesContent":["import { getStatusCodeFromError, UploadThingError } from \"@uploadthing/shared\";\nimport type { Json } from \"@uploadthing/shared\";\n\nimport { UPLOADTHING_VERSION } from \"./constants\";\nimport { formatError } from \"./internal/error-formatter\";\nimport type { RouterWithConfig } from \"./internal/handler\";\nimport {\n  buildPermissionsInfoHandler,\n  buildRequestHandler,\n} from \"./internal/handler\";\nimport { incompatibleNodeGuard } from \"./internal/incompat-node-guard\";\nimport { initLogger } from \"./internal/logger\";\nimport type { FileRouter } from \"./internal/types\";\nimport type { CreateBuilderOptions } from \"./internal/upload-builder\";\nimport { createBuilder } from \"./internal/upload-builder\";\n\nexport * from \"./internal/types\";\nexport { UTApi } from \"./sdk\";\nexport { UploadThingError };\n\ntype MiddlewareArgs = { req: Request; res: undefined; event: undefined };\n\nexport const createUploadthing = <TErrorShape extends Json>(\n  opts?: CreateBuilderOptions<TErrorShape>,\n) => createBuilder<MiddlewareArgs, TErrorShape>(opts);\n\nexport interface ResponseWithCleanup extends Response {\n  /** custom property where a Promise may be put that you can await in for example Cloudflare Workers */\n  cleanup?: Promise<unknown>;\n}\n\n/** @internal */\nexport const INTERNAL_DO_NOT_USE_createRouteHandlerCore = <\n  TRouter extends FileRouter,\n>(\n  opts: RouterWithConfig<TRouter>,\n  adapter: string,\n) => {\n  initLogger(opts.config?.logLevel);\n  incompatibleNodeGuard();\n\n  const requestHandler = buildRequestHandler<TRouter, MiddlewareArgs>(\n    opts,\n    adapter,\n  );\n  const getBuildPerms = buildPermissionsInfoHandler<TRouter>(opts);\n\n  const POST = async (\n    request: Request | { request: Request },\n  ): Promise<Response | ResponseWithCleanup> => {\n    const req = request instanceof Request ? request : request.request;\n    const response = await requestHandler({\n      nativeRequest: req,\n      originalRequest: req,\n      event: undefined,\n      res: undefined,\n    });\n\n    if (response instanceof UploadThingError) {\n      return new Response(JSON.stringify(formatError(response, opts.router)), {\n        status: getStatusCodeFromError(response),\n        headers: {\n          \"x-uploadthing-version\": UPLOADTHING_VERSION,\n        },\n      });\n    }\n    if (response.status !== 200) {\n      // We messed up - this should never happen\n      return new Response(\"An unknown error occured\", {\n        status: 500,\n        headers: {\n          \"x-uploadthing-version\": UPLOADTHING_VERSION,\n        },\n      });\n    }\n\n    const res = new Response(JSON.stringify(response.body), {\n      status: response.status,\n      headers: {\n        \"x-uploadthing-version\": UPLOADTHING_VERSION,\n      },\n    });\n    // @ts-expect-error - this is a custom property\n    res.cleanup = response.cleanup;\n    return res as ResponseWithCleanup;\n  };\n\n  const GET = (request: Request | { request: Request }) => {\n    const _req = request instanceof Request ? request : request.request;\n\n    return new Response(JSON.stringify(getBuildPerms()), {\n      status: 200,\n      headers: {\n        \"x-uploadthing-version\": UPLOADTHING_VERSION,\n      },\n    });\n  };\n\n  return { GET, POST };\n};\n\nexport const createRouteHandler = <TRouter extends FileRouter>(\n  opts: RouterWithConfig<TRouter>,\n) => INTERNAL_DO_NOT_USE_createRouteHandlerCore(opts, \"server\");\n\nexport const extractRouterConfig = (router: FileRouter) =>\n  buildPermissionsInfoHandler({ router })();\n\n/**\n * @deprecated Use {@link createRouteHandler} instead\n */\nexport const createServerHandler = createRouteHandler;\n","{\n  \"name\": \"uploadthing\",\n  \"version\": \"6.3.3\",\n  \"engines\": {\n    \"node\": \">=18.13.0\"\n  },\n  \"license\": \"MIT\",\n  \"exports\": {\n    \"./package.json\": \"./package.json\",\n    \"./client\": {\n      \"types\": \"./dist/client.d.ts\",\n      \"import\": \"./dist/client.mjs\",\n      \"require\": \"./dist/client.js\"\n    },\n    \"./server\": {\n      \"types\": \"./dist/server.d.ts\",\n      \"import\": \"./dist/server.mjs\",\n      \"require\": \"./dist/server.js\"\n    },\n    \"./next\": {\n      \"types\": \"./dist/next.d.ts\",\n      \"import\": \"./dist/next.mjs\",\n      \"require\": \"./dist/next.js\"\n    },\n    \"./next-legacy\": {\n      \"types\": \"./dist/next-legacy.d.ts\",\n      \"import\": \"./dist/next-legacy.mjs\",\n      \"require\": \"./dist/next-legacy.js\"\n    },\n    \"./express\": {\n      \"import\": \"./dist/express.mjs\",\n      \"types\": \"./dist/express.d.ts\",\n      \"require\": \"./dist/express.js\"\n    },\n    \"./tw\": {\n      \"types\": \"./dist/tw.d.ts\",\n      \"import\": \"./dist/tw.mjs\",\n      \"require\": \"./dist/tw.js\"\n    },\n    \"./fastify\": {\n      \"types\": \"./dist/fastify.d.ts\",\n      \"import\": \"./dist/fastify.mjs\",\n      \"require\": \"./dist/fastify.js\"\n    },\n    \"./h3\": {\n      \"types\": \"./dist/h3.d.ts\",\n      \"import\": \"./dist/h3.mjs\",\n      \"require\": \"./dist/h3.js\"\n    }\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"typesVersions\": {\n    \"*\": {\n      \"client\": [\n        \"dist/client.d.ts\"\n      ],\n      \"server\": [\n        \"dist/server.d.ts\"\n      ],\n      \"next\": [\n        \"dist/next.d.ts\"\n      ],\n      \"next-legacy\": [\n        \"dist/next-legacy.d.ts\"\n      ],\n      \"tw\": [\n        \"dist/tw.d.ts\"\n      ],\n      \"express\": [\n        \"dist/express.d.ts\"\n      ],\n      \"fastify\": [\n        \"dist/fastify.d.ts\"\n      ],\n      \"h3\": [\n        \"dist/h3.d.ts\"\n      ]\n    }\n  },\n  \"scripts\": {\n    \"lint\": \"eslint \\\"**/*.{ts,tsx}\\\" --max-warnings 0\",\n    \"build\": \"tsup\",\n    \"clean\": \"git clean -xdf dist node_modules\",\n    \"dev\": \"tsup --watch\",\n    \"test\": \"vitest run\",\n    \"test:watch\": \"vitest\",\n    \"typecheck\": \"tsc --noEmit\"\n  },\n  \"dependencies\": {\n    \"@uploadthing/mime-types\": \"^0.2.2\",\n    \"@uploadthing/shared\": \"^6.2.1\",\n    \"consola\": \"^3.2.3\",\n    \"std-env\": \"^3.7.0\"\n  },\n  \"devDependencies\": {\n    \"@types/express\": \"^4.17.17\",\n    \"@types/react\": \"18.2.33\",\n    \"@uploadthing/eslint-config\": \"0.2.0\",\n    \"@uploadthing/tsconfig\": \"0.1.0\",\n    \"@uploadthing/tsup-config\": \"0.1.0\",\n    \"eslint\": \"^8.56.0\",\n    \"express\": \"^4.18.2\",\n    \"fastify\": \"^4.23.2\",\n    \"h3\": \"^1.8.1\",\n    \"next\": \"14.0.1\",\n    \"solid-js\": \"^1.7.11\",\n    \"tailwindcss\": \"^3.4.1\",\n    \"tsup\": \"6.7.0\",\n    \"type-fest\": \"^3.11.1\",\n    \"typescript\": \"^5.3.3\",\n    \"undici\": \"^6.5.0\",\n    \"vitest\": \"^1.2.2\",\n    \"zod\": \"^3.22.4\"\n  },\n  \"eslintConfig\": {\n    \"root\": true,\n    \"extends\": [\n      \"@uploadthing/eslint-config/base\"\n    ],\n    \"rules\": {\n      \"no-console\": \"error\",\n      \"no-restricted-globals\": [\n        \"error\",\n        {\n          \"name\": \"fetch\",\n          \"message\": \"fetch should be passed as parameter to support overriding default behaviors\"\n        },\n        {\n          \"name\": \"process\",\n          \"message\": \"Use `import { process } from 'std-env` instead\"\n        }\n      ]\n    }\n  }\n}\n","import packageJson from \"../package.json\";\n\nif (!packageJson.version) throw new Error(\"no version found in package.json\");\nexport const UPLOADTHING_VERSION = packageJson.version;\n","import type { UploadThingError } from \"@uploadthing/shared\";\n\nimport type { FileRouter, inferErrorShape } from \"./types\";\n\nexport function defaultErrorFormatter(error: UploadThingError) {\n  return {\n    message: error.message,\n  };\n}\n\nexport function formatError<TRouter extends FileRouter>(\n  error: UploadThingError,\n  router: TRouter,\n): inferErrorShape<TRouter> {\n  const errorFormatter =\n    router[Object.keys(router)[0]]?._def.errorFormatter ??\n    defaultErrorFormatter;\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n  return errorFormatter(error);\n}\n","import { isDevelopment, process } from \"std-env\";\n\nimport type { MimeType } from \"@uploadthing/mime-types/db\";\nimport {\n  generateUploadThingURL,\n  getTypeFromFileName,\n  isObject,\n  objectKeys,\n  fillInputRouteConfig as parseAndExpandInputConfig,\n  safeParseJSON,\n  UploadThingError,\n} from \"@uploadthing/shared\";\nimport type {\n  ContentDisposition,\n  ExpandedRouteConfig,\n  FetchEsque,\n  FileRouterInputKey,\n  Json,\n  UploadedFile,\n} from \"@uploadthing/shared\";\n\nimport { UPLOADTHING_VERSION } from \"../constants\";\nimport { conditionalDevServer } from \"./dev-hook\";\nimport { getFullApiUrl } from \"./get-full-api-url\";\nimport type { LogLevel } from \"./logger\";\nimport { logger } from \"./logger\";\nimport { getParseFn } from \"./parser\";\nimport { VALID_ACTION_TYPES } from \"./types\";\nimport type {\n  ActionType,\n  FileRouter,\n  MiddlewareFnArgs,\n  UTEvents,\n} from \"./types\";\n\n/**\n * Creates a wrapped fetch that will always forward a few headers to the server.\n */\n\nconst createUTFetch = (\n  apiKey: string,\n  fetch: FetchEsque,\n  fePackage: string,\n  beAdapter: string,\n) => {\n  return async (endpoint: `/${string}`, payload: unknown) => {\n    const response = await fetch(generateUploadThingURL(endpoint), {\n      method: \"POST\",\n      body: JSON.stringify(payload),\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"x-uploadthing-api-key\": apiKey,\n        \"x-uploadthing-version\": UPLOADTHING_VERSION,\n        \"x-uploadthing-fe-package\": fePackage,\n        \"x-uploadthing-be-adapter\": beAdapter,\n      },\n    });\n\n    return response;\n  };\n};\n\nconst fileCountLimitHit = (\n  files: { name: string }[],\n  routeConfig: ExpandedRouteConfig,\n) => {\n  const counts: Record<string, number> = {};\n\n  files.forEach((file) => {\n    const type = getTypeFromFileName(file.name, objectKeys(routeConfig));\n\n    if (!counts[type]) {\n      counts[type] = 1;\n    } else {\n      counts[type] += 1;\n    }\n  });\n\n  for (const _key in counts) {\n    const key = _key as FileRouterInputKey;\n    const count = counts[key];\n    const limit = routeConfig[key]?.maxFileCount;\n\n    if (!limit) {\n      logger.error(routeConfig, key);\n      throw new UploadThingError({\n        code: \"BAD_REQUEST\",\n        message: \"Invalid config during file count\",\n        cause: `Expected route config to have a maxFileCount for key ${key} but none was found.`,\n      });\n    }\n\n    if (count > limit) {\n      return { limitHit: true, type: key, limit, count };\n    }\n  }\n\n  return { limitHit: false };\n};\n\ntype RouteHandlerConfig = {\n  logLevel?: LogLevel;\n  callbackUrl?: string;\n  uploadthingId?: string;\n  uploadthingSecret?: string;\n  /**\n   * Used to determine whether to run dev hook or not\n   * @default `env.NODE_ENV === \"development\" || env.NODE_ENV === \"dev\"`\n   */\n  isDev?: boolean;\n  /**\n   * Used to override the fetch implementation\n   * @default `globalThis.fetch`\n   */\n  fetch?: FetchEsque;\n};\n\nexport type RouterWithConfig<TRouter extends FileRouter> = {\n  router: TRouter;\n  config?: RouteHandlerConfig;\n};\n\nexport type UploadThingResponse = {\n  presignedUrls: string[];\n  pollingJwt: string;\n  key: string;\n  pollingUrl: string;\n  uploadId: string;\n  fileName: string;\n  fileType: MimeType;\n  contentDisposition: ContentDisposition;\n  chunkCount: number;\n  chunkSize: number;\n}[];\n\nexport const buildRequestHandler = <\n  TRouter extends FileRouter,\n  Args extends MiddlewareFnArgs<any, any, any>,\n>(\n  opts: RouterWithConfig<TRouter>,\n  adapter: string,\n) => {\n  return async (input: {\n    nativeRequest: Request;\n\n    // Forward to middleware handler\n    originalRequest: Args[\"req\"];\n    res: Args[\"res\"];\n    event: Args[\"event\"];\n  }): Promise<\n    | UploadThingError\n    | { status: 200; body?: UploadThingResponse; cleanup?: Promise<unknown> }\n  > => {\n    const isDev = opts.config?.isDev ?? isDevelopment;\n    const fetch = opts.config?.fetch ?? globalThis.fetch;\n\n    if (isDev) {\n      logger.info(\"UploadThing dev server is now running!\");\n    }\n\n    const { router, config } = opts;\n    const preferredOrEnvSecret =\n      config?.uploadthingSecret ?? process.env.UPLOADTHING_SECRET;\n\n    const req = input.nativeRequest;\n    const url = new URL(req.url);\n\n    // Get inputs from query and params\n    const params = url.searchParams;\n    const uploadthingHook = req.headers.get(\"uploadthing-hook\") ?? undefined;\n    const slug = params.get(\"slug\") ?? undefined;\n    const actionType = (params.get(\"actionType\") as ActionType) ?? undefined;\n    const utFrontendPackage =\n      req.headers.get(\"x-uploadthing-package\") ?? \"unknown\";\n\n    // Validate inputs\n    if (!slug) {\n      logger.error(\"No slug provided in params:\", params);\n      return new UploadThingError({\n        code: \"BAD_REQUEST\",\n        message: \"No slug provided in params\",\n      });\n    }\n\n    if (slug && typeof slug !== \"string\") {\n      const msg = `Expected slug to be of type 'string', got '${typeof slug}'`;\n      logger.error(msg);\n      return new UploadThingError({\n        code: \"BAD_REQUEST\",\n        message: \"`slug` must be a string\",\n        cause: msg,\n      });\n    }\n    if (actionType && typeof actionType !== \"string\") {\n      const msg = `Expected actionType to be of type 'string', got '${typeof actionType}'`;\n      logger.error(msg);\n      return new UploadThingError({\n        code: \"BAD_REQUEST\",\n        message: \"`actionType` must be a string\",\n        cause: msg,\n      });\n    }\n    if (uploadthingHook && typeof uploadthingHook !== \"string\") {\n      const msg = `Expected uploadthingHook to be of type 'string', got '${typeof uploadthingHook}'`;\n      return new UploadThingError({\n        code: \"BAD_REQUEST\",\n        message: \"`uploadthingHook` must be a string\",\n        cause: msg,\n      });\n    }\n\n    if (!preferredOrEnvSecret) {\n      const msg = `No secret provided, please set UPLOADTHING_SECRET in your env file or in the config`;\n      logger.error(msg);\n      return new UploadThingError({\n        code: \"MISSING_ENV\",\n        message: `No secret provided`,\n        cause: msg,\n      });\n    }\n\n    if (!preferredOrEnvSecret.startsWith(\"sk_\")) {\n      const msg = `Invalid secret provided, UPLOADTHING_SECRET must start with 'sk_'`;\n      logger.error(msg);\n      return new UploadThingError({\n        code: \"MISSING_ENV\",\n        message: \"Invalid API key. API keys must start with 'sk_'.\",\n        cause: msg,\n      });\n    }\n\n    if (utFrontendPackage && typeof utFrontendPackage !== \"string\") {\n      const msg = `Expected x-uploadthing-package to be of type 'string', got '${typeof utFrontendPackage}'`;\n      logger.error(msg);\n      return new UploadThingError({\n        code: \"BAD_REQUEST\",\n        message:\n          \"`x-uploadthing-package` must be a string. eg. '@uploadthing/react'\",\n        cause: msg,\n      });\n    }\n\n    const uploadable = router[slug];\n    if (!uploadable) {\n      const msg = `No file route found for slug ${slug}`;\n      logger.error(msg);\n      return new UploadThingError({\n        code: \"NOT_FOUND\",\n        message: msg,\n      });\n    }\n\n    const utFetch = createUTFetch(\n      preferredOrEnvSecret,\n      fetch,\n      utFrontendPackage,\n      adapter,\n    );\n    logger.debug(\"All request input is valid\", {\n      slug,\n      actionType,\n      uploadthingHook,\n    });\n\n    if (uploadthingHook === \"callback\") {\n      // This is when we receive the webhook from uploadthing\n      const maybeReqBody = await safeParseJSON<{\n        file: UploadedFile;\n        files: unknown;\n        metadata: Record<string, unknown>;\n        input?: Json;\n      }>(req);\n\n      logger.debug(\"Handling callback request with input:\", maybeReqBody);\n\n      if (maybeReqBody instanceof Error) {\n        logger.error(\"Invalid request body\", maybeReqBody);\n        return new UploadThingError({\n          code: \"BAD_REQUEST\",\n          message: \"Invalid request body\",\n          cause: maybeReqBody,\n        });\n      }\n\n      const resolverArgs = {\n        file: maybeReqBody.file,\n        metadata: maybeReqBody.metadata,\n      };\n      logger.debug(\n        \"Running 'onUploadComplete' callback with input:\",\n        resolverArgs,\n      );\n      const res = (await uploadable.resolver(resolverArgs)) as unknown;\n      const payload = {\n        fileKey: maybeReqBody.file.key,\n        callbackData: res ?? null,\n      };\n      logger.debug(\n        \"'onUploadComplete' callback finished. Sending response to UploadThing:\",\n        payload,\n      );\n      const callbackResponse = await utFetch(\"/api/serverCallback\", payload);\n      logger.debug(\n        \"UploadThing responded with status:\",\n        callbackResponse.status,\n      );\n      return { status: 200 };\n    }\n\n    if (!actionType || !VALID_ACTION_TYPES.includes(actionType)) {\n      // This would either be someone spamming or the AWS webhook\n      const msg = `Expected ${VALID_ACTION_TYPES.map((x) => `\"${x}\"`)\n        .join(\", \")\n        .replace(/,(?!.*,)/, \" or\")} but got \"${actionType}\"`;\n      logger.error(\"Invalid action type.\", msg);\n      return new UploadThingError({\n        code: \"BAD_REQUEST\",\n        cause: `Invalid action type ${actionType}`,\n        message: msg,\n      });\n    }\n\n    switch (actionType) {\n      case \"upload\": {\n        const maybeInput = await safeParseJSON<UTEvents[\"upload\"]>(req);\n\n        if (maybeInput instanceof Error) {\n          logger.error(\"Invalid request body\", maybeInput);\n          return new UploadThingError({\n            code: \"BAD_REQUEST\",\n            message: \"Invalid request body\",\n            cause: maybeInput,\n          });\n        }\n\n        logger.debug(\"Handling upload request with input:\", maybeInput);\n        const { files, input: userInput } = maybeInput;\n\n        // validate the input\n        let parsedInput: Json = {};\n        try {\n          logger.debug(\"Parsing input\");\n          const inputParser = uploadable._def.inputParser;\n          parsedInput = await getParseFn(inputParser)(userInput);\n          logger.debug(\"Input parsed successfully\", parsedInput);\n        } catch (error) {\n          logger.error(\"An error occured trying to parse input\", error);\n          return new UploadThingError({\n            code: \"BAD_REQUEST\",\n            message: \"Invalid input.\",\n            cause: error,\n          });\n        }\n\n        let metadata: Json = {};\n        try {\n          logger.debug(\"Running middleware\");\n          metadata = await uploadable._def.middleware({\n            req: input.originalRequest,\n            res: input.res,\n            event: input.event,\n            input: parsedInput,\n            files,\n          });\n          logger.debug(\"Middleware finished successfully with:\", metadata);\n        } catch (error) {\n          logger.error(\"An error occured in your middleware function\", error);\n          if (error instanceof UploadThingError) return error;\n          return new UploadThingError({\n            code: \"INTERNAL_SERVER_ERROR\",\n            message: \"Failed to run middleware.\",\n            cause: error,\n          });\n        }\n\n        // Validate without Zod (for now)\n        if (\n          !Array.isArray(files) ||\n          !files.every(\n            (f) =>\n              isObject(f) &&\n              typeof f.name === \"string\" &&\n              typeof f.size === \"number\",\n          )\n        ) {\n          const msg = `Expected files to be of type '{name:string, size:number}[]', got '${JSON.stringify(\n            files,\n          )}'`;\n          logger.error(msg);\n          return new UploadThingError({\n            code: \"BAD_REQUEST\",\n            message: \"Files must be an array of objects with name and size\",\n            cause: msg,\n          });\n        }\n\n        // FILL THE ROUTE CONFIG so the server only has one happy path\n        let parsedConfig: ReturnType<typeof parseAndExpandInputConfig>;\n        try {\n          logger.debug(\"Parsing route config\", uploadable._def.routerConfig);\n          parsedConfig = parseAndExpandInputConfig(\n            uploadable._def.routerConfig,\n          );\n          logger.debug(\"Route config parsed successfully\", parsedConfig);\n        } catch (error) {\n          logger.error(\"Invalid route config\", error);\n          return new UploadThingError({\n            code: \"BAD_REQUEST\",\n            message: \"Invalid config.\",\n            cause: error,\n          });\n        }\n\n        try {\n          logger.debug(\"Checking file count limit\", files);\n          const { limitHit, count, limit, type } = fileCountLimitHit(\n            files,\n            parsedConfig,\n          );\n          if (limitHit) {\n            const msg = `You uploaded ${count} files of type '${type}', but the limit for that type is ${limit}`;\n            logger.error(msg);\n            return new UploadThingError({\n              code: \"BAD_REQUEST\",\n              message: \"File limit exceeded\",\n              cause: msg,\n            });\n          }\n          logger.debug(\"File count limit check passed\");\n        } catch (error) {\n          logger.error(\"Invalid route config\", error);\n          return new UploadThingError({\n            code: \"BAD_REQUEST\",\n            message: \"Invalid config.\",\n            cause: error,\n          });\n        }\n\n        const callbackUrl = resolveCallbackUrl({ config, req, url, isDev });\n        logger.debug(\n          \"Retrieving presigned URLs from UploadThing. Callback URL is:\",\n          callbackUrl.href,\n        );\n        const uploadthingApiResponse = await utFetch(\"/api/prepareUpload\", {\n          files: files,\n\n          routeConfig: parsedConfig,\n\n          metadata,\n          callbackUrl: callbackUrl.origin + callbackUrl.pathname,\n          callbackSlug: slug,\n        });\n\n        // This is when we send the response back to the user's form so they can submit the files\n        const parsedResponse = await safeParseJSON<UploadThingResponse>(\n          uploadthingApiResponse,\n        );\n\n        if (!uploadthingApiResponse.ok || parsedResponse instanceof Error) {\n          logger.error(\"Unable to get presigned URLs\", parsedResponse);\n          return new UploadThingError({\n            code: \"URL_GENERATION_FAILED\",\n            message: \"Unable to get presigned urls\",\n            cause: parsedResponse,\n          });\n        }\n\n        logger.debug(\"UploadThing responded with:\", parsedResponse);\n        logger.debug(\"Sending presigned URLs to client\");\n\n        // This is when we send the response back to the user's form so they can submit the files\n\n        let promise: Promise<unknown> | undefined = undefined;\n        if (isDev) {\n          promise = Promise.all(\n            parsedResponse.map((file) =>\n              conditionalDevServer({\n                fileKey: file.key,\n                apiKey: preferredOrEnvSecret,\n                fetch,\n              }).catch((error) => {\n                logger.error(\"Err\", error);\n              }),\n            ),\n          );\n        }\n\n        return {\n          cleanup: promise,\n          body: parsedResponse.map((x) => ({\n            ...x,\n            pollingUrl: generateUploadThingURL(`/api/serverCallback`),\n          })),\n          status: 200,\n        };\n      }\n      case \"multipart-complete\": {\n        const maybeReqBody =\n          await safeParseJSON<UTEvents[\"multipart-complete\"]>(req);\n        if (maybeReqBody instanceof Error) {\n          logger.error(\"Invalid request body\", maybeReqBody);\n          return new UploadThingError({\n            code: \"BAD_REQUEST\",\n            message: \"Invalid request body\",\n            cause: maybeReqBody,\n          });\n        }\n\n        logger.debug(\n          \"Handling multipart-complete request with input:\",\n          maybeReqBody,\n        );\n        logger.debug(\"Notifying UploadThing that multipart upload is complete\");\n\n        const completeRes = await utFetch(\"/api/completeMultipart\", {\n          fileKey: maybeReqBody.fileKey,\n          uploadId: maybeReqBody.uploadId,\n          etags: maybeReqBody.etags,\n        });\n        if (!completeRes.ok) {\n          logger.error(\n            \"Failed to notify UploadThing that multipart upload is complete\",\n          );\n          return new UploadThingError({\n            code: \"UPLOAD_FAILED\",\n            message: \"Failed to complete multipart upload\",\n            cause: completeRes,\n          });\n        }\n\n        logger.debug(\"UploadThing responded with:\", completeRes.status);\n\n        return { status: 200 };\n      }\n      case \"failure\": {\n        const maybeReqBody = await safeParseJSON<UTEvents[\"failure\"]>(req);\n        if (maybeReqBody instanceof Error) {\n          logger.error(\"Invalid request body\", maybeReqBody);\n          return new UploadThingError({\n            code: \"BAD_REQUEST\",\n            message: \"Invalid request body\",\n            cause: maybeReqBody,\n          });\n        }\n        const { fileKey, uploadId } = maybeReqBody;\n        logger.debug(\"Handling failure request with input:\", maybeReqBody);\n        logger.debug(\"Notifying UploadThing that upload failed\");\n\n        // Tell uploadthing to mark the upload as failed\n        const uploadthingApiResponse = await utFetch(\"/api/failureCallback\", {\n          fileKey,\n          uploadId,\n        });\n\n        if (!uploadthingApiResponse.ok) {\n          const parsedResponse = await safeParseJSON<UploadThingResponse>(\n            uploadthingApiResponse,\n          );\n          logger.error(\"Failed to mark upload as failed\", parsedResponse);\n\n          return new UploadThingError({\n            code: \"INTERNAL_SERVER_ERROR\",\n            message: \"Unable to mark upload as failed\",\n            cause: parsedResponse,\n          });\n        }\n\n        logger.debug(\"UploadThing responded with:\", uploadthingApiResponse);\n        logger.debug(\"Running 'onUploadError' callback\");\n\n        try {\n          // Run the onUploadError callback\n          uploadable._def.onUploadError({\n            error: new UploadThingError({\n              code: \"UPLOAD_FAILED\",\n              message: `Upload failed for ${fileKey}`,\n            }),\n            fileKey,\n          });\n        } catch (error) {\n          logger.error(\n            \"Failed to run onUploadError callback. You probably shouldn't be throwing errors in your callback.\",\n            error,\n          );\n\n          return new UploadThingError({\n            code: \"INTERNAL_SERVER_ERROR\",\n            message: \"Failed to run onUploadError callback\",\n            cause: error,\n          });\n        }\n\n        return { status: 200 };\n      }\n      default: {\n        // This should never happen\n        return new UploadThingError({\n          code: \"BAD_REQUEST\",\n          message: `Invalid action type`,\n        });\n      }\n    }\n  };\n};\n\nfunction resolveCallbackUrl(opts: {\n  config: RouterWithConfig<FileRouter>[\"config\"];\n  req: Request;\n  url: URL;\n  isDev: boolean;\n}): URL {\n  let callbackUrl = opts.url;\n  if (opts.config?.callbackUrl) {\n    callbackUrl = getFullApiUrl(opts.config.callbackUrl);\n  } else if (process.env.UPLOADTHING_URL) {\n    callbackUrl = getFullApiUrl(process.env.UPLOADTHING_URL);\n  }\n\n  if (opts.isDev || !callbackUrl.host.includes(\"localhost\")) {\n    return callbackUrl;\n  }\n\n  // Production builds have to have a public URL so UT can send webhook\n  // Parse the URL from the headers\n  const headers = opts.req.headers;\n  let parsedFromHeaders =\n    headers.get(\"origin\") ??\n    headers.get(\"referer\") ??\n    headers.get(\"host\") ??\n    headers.get(\"x-forwarded-host\");\n\n  if (parsedFromHeaders && !parsedFromHeaders.includes(\"http\")) {\n    parsedFromHeaders =\n      (headers.get(\"x-forwarded-proto\") ?? \"https\") + \"://\" + parsedFromHeaders;\n  }\n\n  if (!parsedFromHeaders || parsedFromHeaders.includes(\"localhost\")) {\n    // Didn't find a valid URL in the headers, log a warning and use the original url anyway\n    logger.warn(\n      \"You are using a localhost callback url in production which is not supported.\",\n      \"Read more and learn how to fix it here: https://docs.uploadthing.com/faq#my-callback-runs-in-development-but-not-in-production\",\n    );\n    return callbackUrl;\n  }\n\n  return getFullApiUrl(parsedFromHeaders);\n}\n\nexport const buildPermissionsInfoHandler = <TRouter extends FileRouter>(\n  opts: RouterWithConfig<TRouter>,\n) => {\n  return () => {\n    const r = opts.router;\n\n    const permissions = Object.keys(r).map((k) => {\n      const route = r[k];\n      const config = parseAndExpandInputConfig(route._def.routerConfig);\n      return {\n        slug: k as keyof TRouter,\n        config,\n      };\n    });\n\n    return permissions;\n  };\n};\n","import {\n  generateUploadThingURL,\n  pollForFileData,\n  UploadThingError,\n} from \"@uploadthing/shared\";\nimport type { FetchEsque, FileData, ResponseEsque } from \"@uploadthing/shared\";\n\nimport { UPLOADTHING_VERSION } from \"../constants\";\nimport { logger } from \"./logger\";\n\nconst isValidResponse = (response: ResponseEsque) => {\n  if (!response.ok) return false;\n  if (response.status >= 400) return false;\n  if (!response.headers.has(\"x-uploadthing-version\")) return false;\n\n  return true;\n};\n\nexport const conditionalDevServer = async (opts: {\n  fileKey: string;\n  apiKey: string;\n  fetch: FetchEsque;\n}) => {\n  const fileData = await pollForFileData(\n    {\n      url: generateUploadThingURL(`/api/pollUpload/${opts.fileKey}`),\n      apiKey: opts.apiKey,\n      sdkVersion: UPLOADTHING_VERSION,\n      fetch: opts.fetch,\n    },\n    async (json: { fileData: FileData }) => {\n      const file = json.fileData;\n\n      let callbackUrl = file.callbackUrl + `?slug=${file.callbackSlug}`;\n      if (!callbackUrl.startsWith(\"http\"))\n        callbackUrl = \"http://\" + callbackUrl;\n\n      logger.info(\"SIMULATING FILE UPLOAD WEBHOOK CALLBACK\", callbackUrl);\n\n      const response = await opts.fetch(callbackUrl, {\n        method: \"POST\",\n        body: JSON.stringify({\n          status: \"uploaded\",\n          metadata: JSON.parse(file.metadata ?? \"{}\") as FileData[\"metadata\"],\n          file: {\n            url: `https://utfs.io/f/${encodeURIComponent(opts.fileKey)}`,\n            key: opts.fileKey,\n            name: file.fileName,\n            size: file.fileSize,\n          },\n        }),\n        headers: {\n          \"uploadthing-hook\": \"callback\",\n        },\n      });\n      if (isValidResponse(response)) {\n        logger.success(\n          \"Successfully simulated callback for file\",\n          opts.fileKey,\n        );\n      } else {\n        logger.error(\n          \"Failed to simulate callback for file. Is your webhook configured correctly?\",\n          opts.fileKey,\n        );\n      }\n      return file;\n    },\n  );\n\n  if (fileData !== undefined) return fileData;\n\n  logger.error(`Failed to simulate callback for file ${opts.fileKey}`);\n  throw new UploadThingError({\n    code: \"UPLOAD_FAILED\",\n    message: \"File took too long to upload\",\n  });\n};\n","import type { LogObject, LogType } from \"consola/core\";\nimport { createConsola, LogLevels } from \"consola/core\";\nimport { process } from \"std-env\";\n\nimport { isObject } from \"@uploadthing/shared\";\n\nexport type LogLevel = \"error\" | \"warn\" | \"info\" | \"debug\" | \"trace\";\n\nconst colorize = (str: string, level: LogType) => {\n  // TODO: Maybe check is shell supports colors\n\n  switch (level) {\n    case \"error\":\n    case \"fatal\":\n      return `\\x1b[41m\\x1b[30m${str}\\x1b[0m`;\n    case \"warn\":\n      return `\\x1b[43m\\x1b[30m${str}\\x1b[0m`;\n    case \"info\":\n    case \"log\":\n      return `\\x1b[44m\\x1b[30m${str}\\x1b[0m`;\n    case \"debug\":\n      return `\\x1b[47m\\x1b[30m${str}\\x1b[0m`;\n    case \"trace\":\n      return `\\x1b[47m\\x1b[30m${str}\\x1b[0m`;\n    case \"success\":\n      return `\\x1b[42m\\x1b[30m${str}\\x1b[0m`;\n    default:\n      return str;\n  }\n};\n\nconst icons: { [t in LogType]?: string } = {\n  fatal: \"⨯\",\n  error: \"⨯\",\n  warn: \"⚠️\",\n  info: \"ℹ\",\n  log: \"ℹ\",\n  debug: \"⚙\",\n  trace: \"→\",\n  success: \"✓\",\n};\n\nfunction formatStack(stack: string) {\n  const cwd =\n    \"cwd\" in process && typeof process.cwd === \"function\"\n      ? process.cwd()\n      : \"__UnknownCWD__\";\n  return (\n    \"  \" +\n    stack\n      .split(\"\\n\")\n      .splice(1)\n      .map((l) =>\n        l\n          .trim()\n          .replace(\"file://\", \"\")\n          .replace(cwd + \"/\", \"\"),\n      )\n      .join(\"\\n  \")\n  );\n}\n\nfunction formatArgs(args: any[]) {\n  const fmtArgs = args.map((arg) => {\n    if (isObject(arg) && typeof arg.stack === \"string\") {\n      return (arg.message as string) + \"\\n\" + formatStack(arg.stack);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return arg;\n  });\n\n  return fmtArgs.map((arg) => {\n    if (typeof arg === \"string\") {\n      return arg;\n    }\n    try {\n      // prefer inspect over JSON.stringify because it handles circular references, prints classes etc\n      // eslint-disable-next-line @typescript-eslint/no-var-requires, @typescript-eslint/consistent-type-imports\n      const util = require(\"util\") as typeof import(\"util\");\n      return util.inspect(arg, { depth: 4 });\n    } catch {\n      // fallback to JSON.stringify if inspect fails e.g. if runtime doesn't have util module\n      return JSON.stringify(arg, null, 4);\n    }\n  });\n}\n\nexport const logger = createConsola({\n  reporters: [\n    {\n      log: (logObj: LogObject) => {\n        const { type, tag, date, args } = logObj;\n        const icon = icons[type as LogLevel];\n\n        const logPrefix = colorize(\n          ` ${icon} ${tag} ${date.toLocaleTimeString()} `,\n          type as LogLevel,\n        );\n        const lines = formatArgs(args)\n          .join(\" \") // concat all arguments to one space-separated string (like console does)\n          .split(\"\\n\") // split all the newlines (e.g. from logged JSON.stringified objects)\n          .map((l) => logPrefix + \" \" + l) // prepend the log prefix to each line\n          .join(\"\\n\"); // join all the lines back together\n\n        // eslint-disable-next-line no-console\n        console.log(lines);\n      },\n    },\n  ],\n  defaults: {\n    tag: \"UPLOADTHING\",\n  },\n});\n\nexport const initLogger = (level: LogLevel | undefined) => {\n  // logger.wrapConsole();\n  logger.level = LogLevels[level ?? \"info\"];\n};\n","import { process } from \"std-env\";\n\n/*\n * Returns a full URL to the dev's uploadthing endpoint\n * Can take either an origin, or a pathname, or a full URL\n * and will return the \"closest\" url matching the default\n * `<VERCEL_URL || localhost>/api/uploadthing`\n */\nexport function getFullApiUrl(maybeUrl?: string): URL {\n  const base = (() => {\n    if (typeof window !== \"undefined\") return window.location.origin;\n    if (process.env?.VERCEL_URL) return `https://${process.env.VERCEL_URL}`;\n    return \"http://localhost:3000\";\n  })();\n\n  try {\n    const url = new URL(maybeUrl ?? \"/api/uploadthing\", base);\n    if (url.pathname === \"/\") {\n      url.pathname = \"/api/uploadthing\";\n    }\n    return url;\n  } catch (err) {\n    throw new Error(\n      `Failed to parse '${maybeUrl}' as a URL. Make sure it's a valid URL or path`,\n    );\n  }\n}\n\nexport function resolveMaybeUrlArg(maybeUrl: string | URL | undefined) {\n  return maybeUrl instanceof URL ? maybeUrl : getFullApiUrl(maybeUrl);\n}\n","import type { Json } from \"@uploadthing/shared\";\n\nimport type { MaybePromise } from \"./types\";\n\n// Don't want to use Zod cause it's an optional dependency\nexport type ParseFn<TType> = (input: unknown) => MaybePromise<TType>;\nexport type ParserZodEsque<TInput, TParsedInput extends Json> = {\n  _input: TInput;\n  _output: TParsedInput; // if using .transform etc\n  parse: ParseFn<TParsedInput>;\n};\n\n// In case we add support for more parsers later\nexport type JsonParser = ParserZodEsque<Json, Json>;\n\nexport function getParseFn<TParser extends JsonParser>(\n  parser: TParser,\n): ParseFn<TParser[\"_output\"]> {\n  if (typeof parser.parse === \"function\") {\n    return parser.parse;\n  }\n\n  throw new Error(\"Invalid parser\");\n}\n","/* eslint-disable @typescript-eslint/ban-types */\n\nimport type {\n  FileRouterInputConfig,\n  Json,\n  UploadedFile,\n  UploadThingError,\n} from \"@uploadthing/shared\";\n\nimport type { JsonParser } from \"./parser\";\n\n//\n// Utils\nexport const unsetMarker = \"unsetMarker\" as \"unsetMarker\" & {\n  __brand: \"unsetMarker\";\n};\nexport type UnsetMarker = typeof unsetMarker;\n\nexport type Simplify<TType> = { [TKey in keyof TType]: TType[TKey] } & {};\n\nexport type MaybePromise<TType> = TType | Promise<TType>;\n\n/**\n * Omits the key without removing a potential union\n * @internal\n */\nexport type DistributiveOmit<TObj, TKey extends keyof any> = TObj extends any\n  ? Omit<TObj, TKey>\n  : never;\n\n//\n// Package\ntype ResolverOptions<TParams extends AnyParams> = {\n  metadata: Simplify<\n    TParams[\"_metadata\"] extends UnsetMarker ? undefined : TParams[\"_metadata\"]\n  >;\n\n  file: UploadedFile;\n};\n\nexport type AnyRuntime = \"app\" | \"pages\" | \"web\" | \"express\" | \"fastify\" | \"h3\";\n\nexport type MiddlewareFnArgs<TRequest, TResponse, TEvent> = {\n  req: TRequest;\n  res: TResponse;\n  event: TEvent;\n};\nexport interface AnyParams {\n  _input: any;\n  _metadata: any; // imaginary field used to bind metadata return type to an Upload resolver\n  _middlewareArgs: MiddlewareFnArgs<any, any, any>;\n  _errorShape: any;\n  _errorFn: any; // used for onUploadError\n  _output: any;\n}\n\ntype MiddlewareFn<\n  TInput extends Json | UnsetMarker,\n  TOutput extends Record<string, unknown>,\n  TArgs extends MiddlewareFnArgs<any, any, any>,\n> = (\n  opts: TArgs & {\n    files: UTEvents[\"upload\"][\"files\"];\n    input: TInput extends UnsetMarker ? undefined : TInput;\n  },\n) => MaybePromise<TOutput>;\n\ntype ResolverFn<TOutput extends Json | void, TParams extends AnyParams> = (\n  opts: ResolverOptions<TParams>,\n) => MaybePromise<TOutput>;\n\ntype UploadErrorFn = (input: {\n  error: UploadThingError;\n  fileKey: string;\n}) => void;\n\nexport type ErrorMessage<TError extends string> = TError;\n\nexport interface UploadBuilder<TParams extends AnyParams> {\n  input: <TParser extends JsonParser>(\n    parser: TParams[\"_input\"] extends UnsetMarker\n      ? TParser\n      : ErrorMessage<\"input is already set\">,\n  ) => UploadBuilder<{\n    _input: TParser[\"_output\"];\n    _metadata: TParams[\"_metadata\"];\n    _middlewareArgs: TParams[\"_middlewareArgs\"];\n    _errorShape: TParams[\"_errorShape\"];\n    _errorFn: TParams[\"_errorFn\"];\n    _output: UnsetMarker;\n  }>;\n  middleware: <TOutput extends Record<string, unknown>>(\n    fn: TParams[\"_metadata\"] extends UnsetMarker\n      ? MiddlewareFn<TParams[\"_input\"], TOutput, TParams[\"_middlewareArgs\"]>\n      : ErrorMessage<\"middleware is already set\">,\n  ) => UploadBuilder<{\n    _input: TParams[\"_input\"];\n    _metadata: TOutput;\n    _middlewareArgs: TParams[\"_middlewareArgs\"];\n    _errorShape: TParams[\"_errorShape\"];\n    _errorFn: TParams[\"_errorFn\"];\n    _output: UnsetMarker;\n  }>;\n  onUploadComplete: <TOutput extends Json | void>(\n    fn: ResolverFn<TOutput, TParams>,\n  ) => Uploader<{\n    _input: TParams[\"_input\"];\n    _metadata: TParams[\"_metadata\"];\n    _middlewareArgs: TParams[\"_middlewareArgs\"];\n    _errorShape: TParams[\"_errorShape\"];\n    _errorFn: TParams[\"_errorFn\"];\n    _output: TOutput;\n  }>;\n  onUploadError: (\n    fn: TParams[\"_errorFn\"] extends UnsetMarker\n      ? UploadErrorFn\n      : ErrorMessage<\"onUploadError is already set\">,\n  ) => UploadBuilder<{\n    _input: TParams[\"_input\"];\n    _metadata: TParams[\"_metadata\"];\n    _middlewareArgs: TParams[\"_middlewareArgs\"];\n    _errorShape: TParams[\"_errorShape\"];\n    _errorFn: UploadErrorFn;\n    _output: UnsetMarker;\n  }>;\n}\n\nexport type UploadBuilderDef<TParams extends AnyParams> = {\n  routerConfig: FileRouterInputConfig;\n  inputParser: JsonParser;\n  middleware: MiddlewareFn<TParams[\"_input\"], {}, TParams[\"_middlewareArgs\"]>;\n  errorFormatter: (err: UploadThingError) => TParams[\"_errorShape\"];\n  onUploadError: UploadErrorFn;\n};\n\nexport interface Uploader<TParams extends AnyParams> {\n  _def: TParams & UploadBuilderDef<TParams>;\n  resolver: ResolverFn<TParams[\"_output\"], TParams>;\n}\n\nexport type FileRouter<TParams extends AnyParams = AnyParams> = Record<\n  string,\n  Uploader<TParams>\n>;\n\nexport type inferEndpointInput<TUploader extends Uploader<any>> =\n  TUploader[\"_def\"][\"_input\"] extends UnsetMarker\n    ? undefined\n    : TUploader[\"_def\"][\"_input\"];\n\nexport type inferEndpointOutput<TUploader extends Uploader<any>> =\n  TUploader[\"_def\"][\"_output\"] extends UnsetMarker | void | undefined\n    ? null\n    : TUploader[\"_def\"][\"_output\"];\n\nexport type inferErrorShape<TRouter extends FileRouter> =\n  TRouter[keyof TRouter][\"_def\"][\"_errorShape\"];\n\nexport const VALID_ACTION_TYPES = [\n  \"upload\",\n  \"failure\",\n  \"multipart-complete\",\n] as const;\nexport type ActionType = (typeof VALID_ACTION_TYPES)[number];\n\nexport type UTEvents = {\n  upload: {\n    files: { name: string; size: number }[];\n    input: Json;\n  };\n  failure: {\n    fileKey: string;\n    uploadId: string;\n    s3Error?: string;\n    fileName: string;\n  };\n  \"multipart-complete\": {\n    fileKey: string;\n    uploadId: string;\n    etags: {\n      tag: string;\n      partNumber: number;\n    }[];\n  };\n};\n","import { process } from \"std-env\";\n\nimport { logger } from \"./logger\";\n\nexport function incompatibleNodeGuard() {\n  if (typeof process === \"undefined\") return;\n\n  let major: number | undefined;\n  let minor: number | undefined;\n\n  const maybeNodeVersion = process.versions?.node?.split(\".\");\n  if (maybeNodeVersion) {\n    [major, minor] = maybeNodeVersion.map((v) => parseInt(v, 10));\n  }\n\n  const maybeNodePath = process.env?.NODE;\n  if (!major && maybeNodePath) {\n    const nodeVersion = /v(\\d+)\\.(\\d+)\\.(\\d+)/.exec(maybeNodePath)?.[0];\n    if (nodeVersion) {\n      [major, minor] = nodeVersion\n        .substring(1)\n        .split(\".\")\n        .map((v) => parseInt(v, 10));\n    }\n  }\n\n  if (!major || !minor) return;\n\n  // Require ^18.13.0\n  if (major > 18) return;\n  if (major === 18 && minor >= 13) return;\n\n  logger.fatal(\n    `YOU ARE USING A LEGACY (${major}.${minor}) NODE VERSION WHICH ISN'T OFFICIALLY SUPPORTED. PLEASE UPGRADE TO NODE ^18.13.`,\n  );\n\n  // Kill the process if it isn't going to work correctly anyway\n  // If we've gotten this far we know we have a Node.js runtime so exit is defined. Override std-env type.\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n  (process as any).exit?.(1);\n}\n","import type {\n  FileRouterInputConfig,\n  Json,\n  UploadThingError,\n} from \"@uploadthing/shared\";\n\nimport { defaultErrorFormatter } from \"./error-formatter\";\nimport type {\n  AnyParams,\n  MiddlewareFnArgs,\n  UnsetMarker,\n  UploadBuilder,\n  UploadBuilderDef,\n  Uploader,\n} from \"./types\";\n\nfunction internalCreateBuilder<\n  TMiddlewareArgs extends MiddlewareFnArgs<any, any, any>,\n  TErrorShape extends Json = { message: string },\n>(\n  initDef: Partial<UploadBuilderDef<any>> = {},\n): UploadBuilder<{\n  _input: UnsetMarker;\n  _metadata: UnsetMarker;\n  _middlewareArgs: TMiddlewareArgs;\n  _errorShape: TErrorShape;\n  _errorFn: UnsetMarker;\n  _output: UnsetMarker;\n}> {\n  const _def: UploadBuilderDef<AnyParams> = {\n    // Default router config\n    routerConfig: {\n      image: {\n        maxFileSize: \"4MB\",\n      },\n    },\n\n    inputParser: { parse: () => ({}), _input: {}, _output: {} },\n\n    middleware: () => ({}),\n    onUploadError: () => ({}),\n\n    errorFormatter: initDef.errorFormatter ?? defaultErrorFormatter,\n\n    // Overload with properties passed in\n    ...initDef,\n  };\n\n  return {\n    input(userParser) {\n      return internalCreateBuilder({\n        ..._def,\n        inputParser: userParser,\n      }) as UploadBuilder<any>;\n    },\n    middleware(userMiddleware) {\n      return internalCreateBuilder({\n        ..._def,\n        middleware: userMiddleware,\n      }) as UploadBuilder<any>;\n    },\n    onUploadComplete(userUploadComplete) {\n      return {\n        _def,\n        resolver: userUploadComplete,\n      } as Uploader<any>;\n    },\n    onUploadError(userOnUploadError) {\n      return internalCreateBuilder({\n        ..._def,\n        onUploadError: userOnUploadError,\n      }) as UploadBuilder<any>;\n    },\n  };\n}\n\ntype InOut<\n  TMiddlewareArgs extends MiddlewareFnArgs<any, any, any>,\n  TErrorShape extends Json = { message: string },\n> = (input: FileRouterInputConfig) => UploadBuilder<{\n  _input: UnsetMarker;\n  _metadata: UnsetMarker;\n  _middlewareArgs: TMiddlewareArgs;\n  _errorShape: TErrorShape;\n  _errorFn: UnsetMarker;\n  _output: UnsetMarker;\n}>;\n\nexport type CreateBuilderOptions<TErrorShape extends Json> = {\n  errorFormatter: (err: UploadThingError) => TErrorShape;\n};\n\nexport function createBuilder<\n  TMiddlewareArgs extends MiddlewareFnArgs<any, any, any>,\n  TErrorShape extends Json = { message: string },\n>(\n  opts?: CreateBuilderOptions<TErrorShape>,\n): InOut<TMiddlewareArgs, TErrorShape> {\n  return (input: FileRouterInputConfig) => {\n    return internalCreateBuilder<TMiddlewareArgs, TErrorShape>({\n      routerConfig: input,\n      ...opts,\n    });\n  };\n}\n","import { process } from \"std-env\";\n\nimport type {\n  ACL,\n  ContentDisposition,\n  FetchEsque,\n  Json,\n  MaybeUrl,\n} from \"@uploadthing/shared\";\nimport { generateUploadThingURL, UploadThingError } from \"@uploadthing/shared\";\n\nimport { UPLOADTHING_VERSION } from \"../constants\";\nimport { incompatibleNodeGuard } from \"../internal/incompat-node-guard\";\nimport type { LogLevel } from \"../internal/logger\";\nimport { initLogger, logger } from \"../internal/logger\";\nimport type { FileEsque, Time, UploadFileResponse } from \"./utils\";\nimport {\n  getApiKeyOrThrow,\n  guardServerOnly,\n  parseTimeToSeconds,\n  uploadFilesInternal,\n} from \"./utils\";\n\nexport interface UTApiOptions {\n  /**\n   * Provide a custom fetch function.\n   * @default globalThis.fetch\n   */\n  fetch?: FetchEsque;\n  /**\n   * Provide a custom UploadThing API key.\n   * @default process.env.UPLOADTHING_SECRET\n   */\n  apiKey?: string;\n  /**\n   * @default \"info\"\n   */\n  logLevel?: LogLevel;\n}\n\nexport class UTApi {\n  private fetch: FetchEsque;\n  private apiKey: string | undefined;\n  private defaultHeaders: Record<string, string>;\n\n  constructor(opts?: UTApiOptions) {\n    this.fetch = opts?.fetch ?? globalThis.fetch;\n    this.apiKey = opts?.apiKey ?? process.env.UPLOADTHING_SECRET;\n    this.defaultHeaders = {\n      \"Content-Type\": \"application/json\",\n      \"x-uploadthing-api-key\": this.apiKey!,\n      \"x-uploadthing-version\": UPLOADTHING_VERSION,\n      \"x-uploadthing-be-adapter\": \"server-sdk\",\n    };\n\n    initLogger(opts?.logLevel);\n\n    // Assert some stuff\n    guardServerOnly();\n    getApiKeyOrThrow(this.apiKey);\n    if (!this.apiKey?.startsWith(\"sk_\")) {\n      throw new UploadThingError({\n        code: \"MISSING_ENV\",\n        message: \"Invalid API key. API keys must start with `sk_`.\",\n      });\n    }\n    incompatibleNodeGuard();\n  }\n\n  private async requestUploadThing<T extends Record<string, unknown>>(\n    pathname: `/${string}`,\n    body: Record<string, unknown>,\n    fallbackErrorMessage: string,\n  ) {\n    const url = generateUploadThingURL(pathname);\n    logger.debug(\"Requesting UploadThing:\", {\n      url,\n      body,\n      headers: this.defaultHeaders,\n    });\n    const res = await this.fetch(url, {\n      method: \"POST\",\n      cache: \"no-store\",\n      headers: this.defaultHeaders,\n      body: JSON.stringify(body),\n    });\n    logger.debug(\"UploadThing responsed with status:\", res.status);\n\n    const json = await res.json<T | { error: string }>();\n    if (!res.ok || \"error\" in json) {\n      logger.error(\"Error:\", json);\n      throw new UploadThingError({\n        code: \"INTERNAL_SERVER_ERROR\",\n        message:\n          \"error\" in json && typeof json.error === \"string\"\n            ? json.error\n            : fallbackErrorMessage,\n      });\n    }\n\n    logger.debug(\"UploadThing response:\", json);\n    return json;\n  }\n\n  /**\n   * Upload files to UploadThing storage.\n   *\n   * @example\n   * await uploadFiles(new File([\"foo\"], \"foo.txt\"));\n   *\n   * @example\n   * await uploadFiles([\n   *   new File([\"foo\"], \"foo.txt\"),\n   *   new File([\"bar\"], \"bar.txt\"),\n   * ]);\n   */\n  async uploadFiles<T extends FileEsque | FileEsque[]>(\n    files: T,\n    opts?: {\n      metadata?: Json;\n      contentDisposition?: ContentDisposition;\n      acl?: ACL;\n    },\n  ) {\n    guardServerOnly();\n\n    const filesToUpload: FileEsque[] = Array.isArray(files) ? files : [files];\n    logger.debug(\"Uploading files:\", filesToUpload);\n\n    const uploads = await uploadFilesInternal(\n      {\n        files: filesToUpload,\n        metadata: opts?.metadata ?? {},\n        contentDisposition: opts?.contentDisposition ?? \"inline\",\n        acl: opts?.acl,\n      },\n      {\n        fetch: this.fetch,\n        utRequestHeaders: this.defaultHeaders,\n      },\n    );\n\n    const uploadFileResponse = Array.isArray(files) ? uploads : uploads[0];\n    logger.debug(\"Finished uploading:\", uploadFileResponse);\n\n    return uploadFileResponse as T extends FileEsque[]\n      ? UploadFileResponse[]\n      : UploadFileResponse;\n  }\n\n  /**\n   * @param {string} url The URL of the file to upload\n   * @param {Json} metadata JSON-parseable metadata to attach to the uploaded file(s)\n   *\n   * @example\n   * await uploadFileFromUrl(\"https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\");\n   *\n   * @example\n   * await uploadFileFromUrl([\n   *   \"https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\",\n   *   \"https://uploadthing.com/f/1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg\"\n   * ])\n   */\n  async uploadFilesFromUrl<T extends MaybeUrl | MaybeUrl[]>(\n    urls: T,\n    opts?: {\n      metadata: Json;\n      contentDisposition: ContentDisposition;\n      acl?: ACL;\n    },\n  ) {\n    guardServerOnly();\n\n    const fileUrls: MaybeUrl[] = Array.isArray(urls) ? urls : [urls];\n\n    const formData = new FormData();\n    formData.append(\"metadata\", JSON.stringify(opts?.metadata ?? {}));\n\n    const filesToUpload = await Promise.all(\n      fileUrls.map(async (url) => {\n        if (typeof url === \"string\") url = new URL(url);\n        const filename = url.pathname.split(\"/\").pop() ?? \"unknown-filename\";\n\n        // Download the file on the user's server to avoid egress charges\n        logger.debug(\"Downloading file:\", url);\n        const fileResponse = await this.fetch(url);\n        if (!fileResponse.ok) {\n          throw new UploadThingError({\n            code: \"BAD_REQUEST\",\n            message: \"Failed to download requested file.\",\n            cause: fileResponse,\n          });\n        }\n        logger.debug(\"Finished downloading file. Reading blob...\");\n        const blob = await fileResponse.blob();\n        logger.debug(\"Finished reading blob.\");\n        return Object.assign(blob, { name: filename });\n      }),\n    );\n\n    logger.debug(\"All files downloaded, uploading...\");\n\n    const uploads = await uploadFilesInternal(\n      {\n        files: filesToUpload,\n        metadata: opts?.metadata ?? {},\n        contentDisposition: opts?.contentDisposition ?? \"inline\",\n        acl: opts?.acl,\n      },\n      {\n        fetch: this.fetch,\n        utRequestHeaders: this.defaultHeaders,\n      },\n    );\n\n    const uploadFileResponse = Array.isArray(urls) ? uploads : uploads[0];\n\n    logger.debug(\"Finished uploading:\", uploadFileResponse);\n    return uploadFileResponse as T extends MaybeUrl[]\n      ? UploadFileResponse[]\n      : UploadFileResponse;\n  }\n\n  /**\n   * Request to delete files from UploadThing storage.\n   * @param {string | string[]} fileKeys\n   *\n   * @example\n   * await deleteFiles(\"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\");\n   *\n   * @example\n   * await deleteFiles([\"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\",\"1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg\"])\n   */\n  async deleteFiles(fileKeys: string[] | string) {\n    guardServerOnly();\n\n    if (!Array.isArray(fileKeys)) fileKeys = [fileKeys];\n\n    return this.requestUploadThing<{ success: boolean }>(\n      \"/api/deleteFile\",\n      { fileKeys },\n      \"An unknown error occured while deleting files.\",\n    );\n  }\n\n  /**\n   * Request file URLs from UploadThing storage.\n   * @param {string | string[]} fileKeys\n   *\n   * @example\n   * const data = await getFileUrls(\"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\");\n   * console.log(data); // [{key: \"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\", url: \"https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\"}]\n   *\n   * @example\n   * const data = await getFileUrls([\"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\",\"1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg\"])\n   * console.log(data) // [{key: \"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\", url: \"https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\" },{key: \"1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg\", url: \"https://uploadthing.com/f/1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg\"}]\n   */\n  async getFileUrls(fileKeys: string[] | string) {\n    guardServerOnly();\n\n    if (!Array.isArray(fileKeys)) fileKeys = [fileKeys];\n\n    const json = await this.requestUploadThing<{\n      data: { key: string; url: string }[];\n    }>(\n      \"/api/getFileUrl\",\n      { fileKeys },\n      \"An unknown error occured while retrieving file URLs.\",\n    );\n\n    return json.data;\n  }\n\n  /**\n   * Request file list from UploadThing storage.\n   * @param {object} opts\n   * @param {number} opts.limit The maximum number of files to return\n   * @param {number} opts.offset The number of files to skip\n   *\n   * @example\n   * const data = await listFiles({ limit: 1 });\n   * console.log(data); // { key: \"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\", id: \"2e0fdb64-9957-4262-8e45-f372ba903ac8\" }\n   */\n  async listFiles(opts: { limit?: number; offset?: number }) {\n    guardServerOnly();\n\n    const json = await this.requestUploadThing<{\n      files: {\n        key: string;\n        id: string;\n        status: \"Deletion Pending\" | \"Failed\" | \"Uploaded\" | \"Uploading\";\n      }[];\n    }>(\"/api/listFiles\", opts, \"An unknown error occured while listing files.\");\n\n    return json.files;\n  }\n\n  async renameFiles(\n    updates:\n      | {\n          fileKey: string;\n          newName: string;\n        }\n      | {\n          fileKey: string;\n          newName: string;\n        }[],\n  ) {\n    guardServerOnly();\n\n    if (!Array.isArray(updates)) updates = [updates];\n\n    return this.requestUploadThing<{ success: true }>(\n      \"/api/renameFiles\",\n      { updates },\n      \"An unknown error occured while renaming files.\",\n    );\n  }\n  /** @deprecated Use {@link renameFiles} instead. */\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  public renameFile = this.renameFiles;\n\n  async getUsageInfo() {\n    guardServerOnly();\n\n    return this.requestUploadThing<{\n      totalBytes: number;\n      totalReadable: string;\n      appTotalBytes: number;\n      appTotalReadable: string;\n      filesUploaded: number;\n      limitBytes: number;\n      limitReadable: string;\n    }>(\n      \"/api/getUsageInfo\",\n      {},\n      \"An unknown error occured while getting usage info.\",\n    );\n  }\n\n  /** Request a presigned url for a private file(s) */\n  async getSignedURL(\n    fileKey: string,\n    opts?: {\n      /**\n       * How long the URL will be valid for.\n       * - Must be positive and less than 7 days (604800 seconds).\n       * - You must accept overrides on the UploadThing dashboard for this option to be accepted.\n       * @default app default on UploadThing dashboard\n       */\n      expiresIn?: Time;\n    },\n  ) {\n    guardServerOnly();\n\n    const expiresIn = opts?.expiresIn\n      ? parseTimeToSeconds(opts.expiresIn)\n      : undefined;\n\n    if (opts?.expiresIn && isNaN(expiresIn!)) {\n      throw new UploadThingError({\n        code: \"BAD_REQUEST\",\n        message:\n          \"expiresIn must be a valid time string, for example '1d', '2 days', or a number of seconds.\",\n      });\n    }\n    if (expiresIn && expiresIn > 86400 * 7) {\n      throw new UploadThingError({\n        code: \"BAD_REQUEST\",\n        message: \"expiresIn must be less than 7 days (604800 seconds).\",\n      });\n    }\n\n    const json = await this.requestUploadThing<{ url: string }>(\n      \"/api/requestFileAccess\",\n      { fileKey, expiresIn },\n      \"An unknown error occured while retrieving presigned URLs.\",\n    );\n\n    return json.url;\n  }\n}\n","import { process } from \"std-env\";\nimport type { File as UndiciFile } from \"undici\";\n\nimport type {\n  ACL,\n  ContentDisposition,\n  FetchEsque,\n  Json,\n} from \"@uploadthing/shared\";\nimport {\n  generateUploadThingURL,\n  pollForFileData,\n  UploadThingError,\n} from \"@uploadthing/shared\";\n\nimport { UPLOADTHING_VERSION } from \"../constants\";\nimport { logger } from \"../internal/logger\";\nimport { uploadPart } from \"../internal/multi-part\";\nimport type { UTEvents } from \"../server\";\n\nexport function guardServerOnly() {\n  if (typeof window !== \"undefined\") {\n    throw new UploadThingError({\n      code: \"INTERNAL_SERVER_ERROR\",\n      message: \"The `utapi` can only be used on the server.\",\n    });\n  }\n}\n\nexport function getApiKeyOrThrow(apiKey?: string) {\n  if (apiKey) return apiKey;\n  if (process.env.UPLOADTHING_SECRET) return process.env.UPLOADTHING_SECRET;\n\n  throw new UploadThingError({\n    code: \"MISSING_ENV\",\n    message: \"Missing `UPLOADTHING_SECRET` env variable.\",\n  });\n}\n\nexport type FileEsque = (Blob & { name: string }) | UndiciFile;\n\nexport type UploadData = {\n  key: string;\n  url: string;\n  name: string;\n  size: number;\n};\n\nexport type UploadError = {\n  code: string;\n  message: string;\n  data: any;\n};\n\nexport type UploadFileResponse =\n  | { data: UploadData; error: null }\n  | { data: null; error: UploadError };\n\nexport const uploadFilesInternal = async (\n  data: {\n    files: FileEsque[];\n    metadata: Json;\n    contentDisposition: ContentDisposition;\n    acl?: ACL;\n  },\n  opts: {\n    fetch: FetchEsque;\n    utRequestHeaders: Record<string, string>;\n  },\n) => {\n  // Request presigned URLs for each file\n  const fileData = data.files.map((file) => ({\n    name: file.name ?? \"unnamed-blob\",\n    type: file.type,\n    size: file.size,\n  }));\n  logger.debug(\"Getting presigned URLs for files\", fileData);\n  const res = await opts.fetch(generateUploadThingURL(\"/api/uploadFiles\"), {\n    method: \"POST\",\n    headers: opts.utRequestHeaders,\n    cache: \"no-store\",\n    body: JSON.stringify({\n      files: fileData,\n      metadata: data.metadata,\n      contentDisposition: data.contentDisposition,\n      acl: data.acl,\n    }),\n  });\n\n  if (!res.ok) {\n    const error = await UploadThingError.fromResponse(res);\n    logger.debug(\"Failed getting presigned URLs:\", error);\n    throw error;\n  }\n\n  if (!res.ok) {\n    const error = await UploadThingError.fromResponse(res);\n    logger.debug(\"Failed getting presigned URLs:\", error);\n    throw error;\n  }\n\n  const json = await res.json<{\n    data: {\n      presignedUrls: string[];\n      key: string;\n      fileUrl: string;\n      fileType: string;\n      uploadId: string;\n      chunkSize: number;\n      chunkCount: number;\n    }[];\n  }>();\n\n  logger.debug(\"Got presigned URLs:\", json.data);\n  logger.debug(\"Starting uploads...\");\n\n  // Upload each file to S3 in chunks using multi-part uploads\n  const uploads = await Promise.allSettled(\n    data.files.map(async (file, i) => {\n      const { presignedUrls, key, fileUrl, uploadId, chunkSize } = json.data[i];\n\n      if (!presignedUrls || !Array.isArray(presignedUrls)) {\n        logger.error(\n          \"Failed to generate presigned URL for file:\",\n          file,\n          json.data[i],\n        );\n        throw new UploadThingError({\n          code: \"URL_GENERATION_FAILED\",\n          message: \"Failed to generate presigned URL\",\n          cause: JSON.stringify(json.data[i]),\n        });\n      }\n\n      logger.debug(\n        \"Uploading file\",\n        file.name,\n        \"with\",\n        presignedUrls.length,\n        \"chunks of size\",\n        chunkSize,\n        \"bytes each\",\n      );\n\n      const etags = await Promise.all(\n        presignedUrls.map(async (url, index) => {\n          const offset = chunkSize * index;\n          const end = Math.min(offset + chunkSize, file.size);\n          const chunk = file.slice(offset, end);\n\n          const etag = await uploadPart({\n            fetch: opts.fetch,\n            url,\n            chunk: chunk as Blob,\n            contentDisposition: data.contentDisposition,\n            contentType: file.type,\n            fileName: file.name,\n            maxRetries: 10,\n            key,\n            utRequestHeaders: opts.utRequestHeaders,\n          });\n\n          logger.debug(\"Part\", index + 1, \"uploaded successfully:\", etag);\n\n          return { tag: etag, partNumber: index + 1 };\n        }),\n      );\n\n      logger.debug(\n        \"File\",\n        file.name,\n        \"uploaded successfully. Notifying UploadThing to complete multipart upload.\",\n      );\n\n      // Complete multipart upload\n      const completionRes = await opts.fetch(\n        generateUploadThingURL(\"/api/completeMultipart\"),\n        {\n          method: \"POST\",\n          body: JSON.stringify({\n            fileKey: key,\n            uploadId,\n            etags,\n          } satisfies UTEvents[\"multipart-complete\"]),\n          headers: opts.utRequestHeaders,\n        },\n      );\n\n      logger.debug(\"UploadThing responsed with status:\", completionRes.status);\n      logger.debug(\"Polling for file data...\");\n\n      // Poll for file to be available\n      await pollForFileData({\n        url: generateUploadThingURL(`/api/pollUpload/${key}`),\n        apiKey: opts.utRequestHeaders[\"x-uploadthing-api-key\"],\n        sdkVersion: UPLOADTHING_VERSION,\n        fetch: opts.fetch,\n      });\n\n      logger.debug(\"Polling complete.\");\n\n      return {\n        key,\n        url: fileUrl,\n        name: file.name,\n        size: file.size,\n      };\n    }),\n  );\n\n  logger.debug(\"All uploads complete, aggregating results...\");\n\n  return uploads.map((upload) => {\n    if (upload.status === \"fulfilled\") {\n      const data = upload.value satisfies UploadData;\n      return { data, error: null };\n    }\n    // We only throw UploadThingErrors, so this is safe\n    const reason = upload.reason as UploadThingError;\n    const error = UploadThingError.toObject(reason) satisfies UploadError;\n    return { data: null, error };\n  });\n};\n\ntype TimeShort = \"s\" | \"m\" | \"h\" | \"d\";\ntype TimeLong = \"second\" | \"minute\" | \"hour\" | \"day\";\ntype SuggestedNumbers = 2 | 3 | 4 | 5 | 6 | 7 | 10 | 15 | 30 | 60;\n// eslint-disable-next-line @typescript-eslint/ban-types\ntype AutoCompleteableNumber = SuggestedNumbers | (number & {});\nexport type Time =\n  | number\n  | `1${TimeShort}`\n  | `${AutoCompleteableNumber}${TimeShort}`\n  | `1 ${TimeLong}`\n  | `${AutoCompleteableNumber} ${TimeLong}s`;\n\nexport function parseTimeToSeconds(time: Time) {\n  const match = time.toString().split(/(\\d+)/).filter(Boolean);\n  const num = Number(match[0]);\n  const unit = (match[1] ?? \"s\").trim().slice(0, 1) as TimeShort;\n\n  const multiplier = {\n    s: 1,\n    m: 60,\n    h: 3600,\n    d: 86400,\n  }[unit];\n\n  return num * multiplier;\n}\n","import { generateUploadThingURL, UploadThingError } from \"@uploadthing/shared\";\nimport type { ContentDisposition, FetchEsque } from \"@uploadthing/shared\";\n\nimport { maybeParseResponseXML } from \"./s3-error-parser\";\n\n/**\n * Used by server uploads where progress is not needed.\n * Uses normal fetch API.\n */\nexport async function uploadPart(\n  opts: {\n    fetch: FetchEsque;\n    url: string;\n    key: string;\n    chunk: Blob;\n    contentType: string;\n    contentDisposition: ContentDisposition;\n    fileName: string;\n    maxRetries: number;\n    utRequestHeaders: Record<string, string>;\n  },\n  retryCount = 0,\n) {\n  const s3Res = await opts.fetch(opts.url, {\n    method: \"PUT\",\n    body: opts.chunk,\n    headers: {\n      \"Content-Type\": opts.contentType,\n      \"Content-Disposition\": [\n        opts.contentDisposition,\n        `filename=\"${encodeURI(opts.fileName)}\"`,\n        `filename*=UTF-8''${encodeURI(opts.fileName)}`,\n      ].join(\"; \"),\n    },\n  });\n\n  if (s3Res.ok) {\n    const etag = s3Res.headers.get(\"Etag\");\n    if (!etag) {\n      throw new UploadThingError({\n        code: \"UPLOAD_FAILED\",\n        message: \"Missing Etag header from uploaded part\",\n      });\n    }\n    return etag.replace(/\"/g, \"\");\n  }\n\n  if (retryCount < opts.maxRetries) {\n    // Retry after exponential backoff\n    const delay = 2 ** retryCount * 1000;\n    await new Promise((r) => setTimeout(r, delay));\n    return uploadPart(opts, retryCount++);\n  }\n\n  // Max retries exceeded, tell UT server that upload failed\n  await opts.fetch(generateUploadThingURL(\"/api/failureCallback\"), {\n    method: \"POST\",\n    body: JSON.stringify({\n      fileKey: opts.key,\n    }),\n    headers: opts.utRequestHeaders,\n  });\n\n  const text = await s3Res.text();\n  const parsed = maybeParseResponseXML(text);\n  if (parsed?.message) {\n    throw new UploadThingError({\n      code: \"UPLOAD_FAILED\",\n      message: parsed.message,\n    });\n  }\n  throw new UploadThingError({\n    code: \"UPLOAD_FAILED\",\n    message: \"Failed to upload file to storage provider\",\n    cause: s3Res,\n  });\n}\n\n/**\n * Used by client uploads where progress is needed.\n * Uses XMLHttpRequest.\n */\nexport async function uploadPartWithProgress(\n  opts: {\n    url: string;\n    chunk: Blob;\n    fileType: string;\n    fileName: string;\n    contentDisposition: ContentDisposition;\n    maxRetries: number;\n    onProgress: (progressDelta: number) => void;\n  },\n  retryCount = 0,\n) {\n  return new Promise<string>((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n\n    xhr.open(\"PUT\", opts.url, true);\n    xhr.setRequestHeader(\"Content-Type\", opts.fileType);\n    xhr.setRequestHeader(\n      \"Content-Disposition\",\n      [\n        opts.contentDisposition,\n        `filename=\"${encodeURI(opts.fileName)}\"`,\n        `filename*=UTF-8''${encodeURI(opts.fileName)}`,\n      ].join(\"; \"),\n    );\n\n    xhr.onload = async () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        const etag = xhr.getResponseHeader(\"Etag\");\n        etag ? resolve(etag) : reject(\"NO ETAG\");\n      } else if (retryCount < opts.maxRetries) {\n        // Add a delay before retrying (exponential backoff can be used)\n        const delay = Math.pow(2, retryCount) * 1000;\n        await new Promise((res) => setTimeout(res, delay));\n        await uploadPartWithProgress(opts, retryCount + 1); // Retry the request\n      } else {\n        reject(\"Max retries exceeded\");\n      }\n    };\n\n    let lastProgress = 0;\n\n    xhr.onerror = async () => {\n      lastProgress = 0;\n      if (retryCount < opts.maxRetries) {\n        // Add a delay before retrying (exponential backoff can be used)\n        const delay = Math.pow(2, retryCount) * 100;\n        await new Promise((res) => setTimeout(res, delay));\n        await uploadPartWithProgress(opts, retryCount + 1); // Retry the request\n      } else {\n        reject(\"Max retries exceeded\");\n      }\n    };\n\n    xhr.upload.onprogress = (e) => {\n      const delta = e.loaded - lastProgress;\n      lastProgress += delta;\n      opts.onProgress(delta);\n    };\n\n    xhr.send(opts.chunk);\n  });\n}\n","import type { UploadThingError } from \"@uploadthing/shared\";\n\nexport const maybeParseResponseXML = (maybeXml: string) => {\n  const codeMatch = maybeXml.match(/<Code>(.*?)<\\/Code>/s);\n  const messageMatch = maybeXml.match(/<Message>(.*?)<\\/Message>/s);\n\n  const code = codeMatch?.[1];\n  const message = messageMatch?.[1];\n\n  if (!code || !message) return null;\n\n  return { code: s3CodeToUploadThingCode[code] ?? DEFAULT_ERROR_CODE, message };\n};\n\n/**\n * Map S3 error codes to UploadThing error codes\n *\n * This is a subset of the S3 error codes, based on what seemed most likely to\n * occur in uploadthing. For a full list of S3 error codes, see:\n * https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html\n */\nconst DEFAULT_ERROR_CODE = \"UPLOAD_FAILED\";\nconst s3CodeToUploadThingCode: Record<string, UploadThingError[\"code\"]> = {\n  AccessDenied: \"FORBIDDEN\", // 403 Forbidden\n  EntityTooSmall: \"TOO_SMALL\", // 400 Bad Request\n  EntityTooLarge: \"TOO_LARGE\", // 400 Bad Request\n  ExpiredToken: \"FORBIDDEN\", // 400 Bad Request\n  IncorrectNumberOfFilesInPostRequest: \"TOO_MANY_FILES\", // 400 Bad Request\n  InternalError: \"INTERNAL_SERVER_ERROR\", // 500 Internal Server Error\n  KeyTooLongError: \"KEY_TOO_LONG\", // 400 Bad Request\n  MaxMessageLengthExceeded: \"TOO_LARGE\", // 400 Bad Request\n};\n"],"mappings":"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","names":["import_shared","import_std_env","import_shared","import_shared","import_std_env","parseAndExpandInputConfig","import_std_env","import_std_env","import_shared","import_std_env","import_shared","import_shared","data"]}