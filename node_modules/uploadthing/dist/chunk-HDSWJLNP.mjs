import {
  uploadPart
} from "./chunk-S3R3VXRK.mjs";
import {
  UPLOADTHING_VERSION,
  buildPermissionsInfoHandler,
  buildRequestHandler,
  createBuilder,
  formatError,
  incompatibleNodeGuard,
  initLogger,
  logger
} from "./chunk-VF56OB6T.mjs";

// src/server.ts
import { getStatusCodeFromError, UploadThingError as UploadThingError3 } from "@uploadthing/shared";

// src/sdk/index.ts
import { process as process2 } from "std-env";
import { generateUploadThingURL as generateUploadThingURL2, UploadThingError as UploadThingError2 } from "@uploadthing/shared";

// src/sdk/utils.ts
import { process } from "std-env";
import {
  generateUploadThingURL,
  pollForFileData,
  UploadThingError
} from "@uploadthing/shared";
function guardServerOnly() {
  if (typeof window !== "undefined") {
    throw new UploadThingError({
      code: "INTERNAL_SERVER_ERROR",
      message: "The `utapi` can only be used on the server."
    });
  }
}
function getApiKeyOrThrow(apiKey) {
  if (apiKey)
    return apiKey;
  if (process.env.UPLOADTHING_SECRET)
    return process.env.UPLOADTHING_SECRET;
  throw new UploadThingError({
    code: "MISSING_ENV",
    message: "Missing `UPLOADTHING_SECRET` env variable."
  });
}
var uploadFilesInternal = async (data, opts) => {
  const fileData = data.files.map((file) => ({
    name: file.name ?? "unnamed-blob",
    type: file.type,
    size: file.size
  }));
  logger.debug("Getting presigned URLs for files", fileData);
  const res = await opts.fetch(generateUploadThingURL("/api/uploadFiles"), {
    method: "POST",
    headers: opts.utRequestHeaders,
    cache: "no-store",
    body: JSON.stringify({
      files: fileData,
      metadata: data.metadata,
      contentDisposition: data.contentDisposition,
      acl: data.acl
    })
  });
  if (!res.ok) {
    const error = await UploadThingError.fromResponse(res);
    logger.debug("Failed getting presigned URLs:", error);
    throw error;
  }
  if (!res.ok) {
    const error = await UploadThingError.fromResponse(res);
    logger.debug("Failed getting presigned URLs:", error);
    throw error;
  }
  const json = await res.json();
  logger.debug("Got presigned URLs:", json.data);
  logger.debug("Starting uploads...");
  const uploads = await Promise.allSettled(
    data.files.map(async (file, i) => {
      const { presignedUrls, key, fileUrl, uploadId, chunkSize } = json.data[i];
      if (!presignedUrls || !Array.isArray(presignedUrls)) {
        logger.error(
          "Failed to generate presigned URL for file:",
          file,
          json.data[i]
        );
        throw new UploadThingError({
          code: "URL_GENERATION_FAILED",
          message: "Failed to generate presigned URL",
          cause: JSON.stringify(json.data[i])
        });
      }
      logger.debug(
        "Uploading file",
        file.name,
        "with",
        presignedUrls.length,
        "chunks of size",
        chunkSize,
        "bytes each"
      );
      const etags = await Promise.all(
        presignedUrls.map(async (url, index) => {
          const offset = chunkSize * index;
          const end = Math.min(offset + chunkSize, file.size);
          const chunk = file.slice(offset, end);
          const etag = await uploadPart({
            fetch: opts.fetch,
            url,
            chunk,
            contentDisposition: data.contentDisposition,
            contentType: file.type,
            fileName: file.name,
            maxRetries: 10,
            key,
            utRequestHeaders: opts.utRequestHeaders
          });
          logger.debug("Part", index + 1, "uploaded successfully:", etag);
          return { tag: etag, partNumber: index + 1 };
        })
      );
      logger.debug(
        "File",
        file.name,
        "uploaded successfully. Notifying UploadThing to complete multipart upload."
      );
      const completionRes = await opts.fetch(
        generateUploadThingURL("/api/completeMultipart"),
        {
          method: "POST",
          body: JSON.stringify({
            fileKey: key,
            uploadId,
            etags
          }),
          headers: opts.utRequestHeaders
        }
      );
      logger.debug("UploadThing responsed with status:", completionRes.status);
      logger.debug("Polling for file data...");
      await pollForFileData({
        url: generateUploadThingURL(`/api/pollUpload/${key}`),
        apiKey: opts.utRequestHeaders["x-uploadthing-api-key"],
        sdkVersion: UPLOADTHING_VERSION,
        fetch: opts.fetch
      });
      logger.debug("Polling complete.");
      return {
        key,
        url: fileUrl,
        name: file.name,
        size: file.size
      };
    })
  );
  logger.debug("All uploads complete, aggregating results...");
  return uploads.map((upload) => {
    if (upload.status === "fulfilled") {
      const data2 = upload.value;
      return { data: data2, error: null };
    }
    const reason = upload.reason;
    const error = UploadThingError.toObject(reason);
    return { data: null, error };
  });
};
function parseTimeToSeconds(time) {
  const match = time.toString().split(/(\d+)/).filter(Boolean);
  const num = Number(match[0]);
  const unit = (match[1] ?? "s").trim().slice(0, 1);
  const multiplier = {
    s: 1,
    m: 60,
    h: 3600,
    d: 86400
  }[unit];
  return num * multiplier;
}

// src/sdk/index.ts
var UTApi = class {
  constructor(opts) {
    /** @deprecated Use {@link renameFiles} instead. */
    // eslint-disable-next-line @typescript-eslint/unbound-method
    this.renameFile = this.renameFiles;
    var _a;
    this.fetch = (opts == null ? void 0 : opts.fetch) ?? globalThis.fetch;
    this.apiKey = (opts == null ? void 0 : opts.apiKey) ?? process2.env.UPLOADTHING_SECRET;
    this.defaultHeaders = {
      "Content-Type": "application/json",
      "x-uploadthing-api-key": this.apiKey,
      "x-uploadthing-version": UPLOADTHING_VERSION,
      "x-uploadthing-be-adapter": "server-sdk"
    };
    initLogger(opts == null ? void 0 : opts.logLevel);
    guardServerOnly();
    getApiKeyOrThrow(this.apiKey);
    if (!((_a = this.apiKey) == null ? void 0 : _a.startsWith("sk_"))) {
      throw new UploadThingError2({
        code: "MISSING_ENV",
        message: "Invalid API key. API keys must start with `sk_`."
      });
    }
    incompatibleNodeGuard();
  }
  async requestUploadThing(pathname, body, fallbackErrorMessage) {
    const url = generateUploadThingURL2(pathname);
    logger.debug("Requesting UploadThing:", {
      url,
      body,
      headers: this.defaultHeaders
    });
    const res = await this.fetch(url, {
      method: "POST",
      cache: "no-store",
      headers: this.defaultHeaders,
      body: JSON.stringify(body)
    });
    logger.debug("UploadThing responsed with status:", res.status);
    const json = await res.json();
    if (!res.ok || "error" in json) {
      logger.error("Error:", json);
      throw new UploadThingError2({
        code: "INTERNAL_SERVER_ERROR",
        message: "error" in json && typeof json.error === "string" ? json.error : fallbackErrorMessage
      });
    }
    logger.debug("UploadThing response:", json);
    return json;
  }
  /**
   * Upload files to UploadThing storage.
   *
   * @example
   * await uploadFiles(new File(["foo"], "foo.txt"));
   *
   * @example
   * await uploadFiles([
   *   new File(["foo"], "foo.txt"),
   *   new File(["bar"], "bar.txt"),
   * ]);
   */
  async uploadFiles(files, opts) {
    guardServerOnly();
    const filesToUpload = Array.isArray(files) ? files : [files];
    logger.debug("Uploading files:", filesToUpload);
    const uploads = await uploadFilesInternal(
      {
        files: filesToUpload,
        metadata: (opts == null ? void 0 : opts.metadata) ?? {},
        contentDisposition: (opts == null ? void 0 : opts.contentDisposition) ?? "inline",
        acl: opts == null ? void 0 : opts.acl
      },
      {
        fetch: this.fetch,
        utRequestHeaders: this.defaultHeaders
      }
    );
    const uploadFileResponse = Array.isArray(files) ? uploads : uploads[0];
    logger.debug("Finished uploading:", uploadFileResponse);
    return uploadFileResponse;
  }
  /**
   * @param {string} url The URL of the file to upload
   * @param {Json} metadata JSON-parseable metadata to attach to the uploaded file(s)
   *
   * @example
   * await uploadFileFromUrl("https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg");
   *
   * @example
   * await uploadFileFromUrl([
   *   "https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg",
   *   "https://uploadthing.com/f/1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg"
   * ])
   */
  async uploadFilesFromUrl(urls, opts) {
    guardServerOnly();
    const fileUrls = Array.isArray(urls) ? urls : [urls];
    const formData = new FormData();
    formData.append("metadata", JSON.stringify((opts == null ? void 0 : opts.metadata) ?? {}));
    const filesToUpload = await Promise.all(
      fileUrls.map(async (url) => {
        if (typeof url === "string")
          url = new URL(url);
        const filename = url.pathname.split("/").pop() ?? "unknown-filename";
        logger.debug("Downloading file:", url);
        const fileResponse = await this.fetch(url);
        if (!fileResponse.ok) {
          throw new UploadThingError2({
            code: "BAD_REQUEST",
            message: "Failed to download requested file.",
            cause: fileResponse
          });
        }
        logger.debug("Finished downloading file. Reading blob...");
        const blob = await fileResponse.blob();
        logger.debug("Finished reading blob.");
        return Object.assign(blob, { name: filename });
      })
    );
    logger.debug("All files downloaded, uploading...");
    const uploads = await uploadFilesInternal(
      {
        files: filesToUpload,
        metadata: (opts == null ? void 0 : opts.metadata) ?? {},
        contentDisposition: (opts == null ? void 0 : opts.contentDisposition) ?? "inline",
        acl: opts == null ? void 0 : opts.acl
      },
      {
        fetch: this.fetch,
        utRequestHeaders: this.defaultHeaders
      }
    );
    const uploadFileResponse = Array.isArray(urls) ? uploads : uploads[0];
    logger.debug("Finished uploading:", uploadFileResponse);
    return uploadFileResponse;
  }
  /**
   * Request to delete files from UploadThing storage.
   * @param {string | string[]} fileKeys
   *
   * @example
   * await deleteFiles("2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg");
   *
   * @example
   * await deleteFiles(["2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg","1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg"])
   */
  async deleteFiles(fileKeys) {
    guardServerOnly();
    if (!Array.isArray(fileKeys))
      fileKeys = [fileKeys];
    return this.requestUploadThing(
      "/api/deleteFile",
      { fileKeys },
      "An unknown error occured while deleting files."
    );
  }
  /**
   * Request file URLs from UploadThing storage.
   * @param {string | string[]} fileKeys
   *
   * @example
   * const data = await getFileUrls("2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg");
   * console.log(data); // [{key: "2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg", url: "https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg"}]
   *
   * @example
   * const data = await getFileUrls(["2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg","1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg"])
   * console.log(data) // [{key: "2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg", url: "https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg" },{key: "1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg", url: "https://uploadthing.com/f/1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg"}]
   */
  async getFileUrls(fileKeys) {
    guardServerOnly();
    if (!Array.isArray(fileKeys))
      fileKeys = [fileKeys];
    const json = await this.requestUploadThing(
      "/api/getFileUrl",
      { fileKeys },
      "An unknown error occured while retrieving file URLs."
    );
    return json.data;
  }
  /**
   * Request file list from UploadThing storage.
   * @param {object} opts
   * @param {number} opts.limit The maximum number of files to return
   * @param {number} opts.offset The number of files to skip
   *
   * @example
   * const data = await listFiles({ limit: 1 });
   * console.log(data); // { key: "2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg", id: "2e0fdb64-9957-4262-8e45-f372ba903ac8" }
   */
  async listFiles(opts) {
    guardServerOnly();
    const json = await this.requestUploadThing("/api/listFiles", opts, "An unknown error occured while listing files.");
    return json.files;
  }
  async renameFiles(updates) {
    guardServerOnly();
    if (!Array.isArray(updates))
      updates = [updates];
    return this.requestUploadThing(
      "/api/renameFiles",
      { updates },
      "An unknown error occured while renaming files."
    );
  }
  async getUsageInfo() {
    guardServerOnly();
    return this.requestUploadThing(
      "/api/getUsageInfo",
      {},
      "An unknown error occured while getting usage info."
    );
  }
  /** Request a presigned url for a private file(s) */
  async getSignedURL(fileKey, opts) {
    guardServerOnly();
    const expiresIn = (opts == null ? void 0 : opts.expiresIn) ? parseTimeToSeconds(opts.expiresIn) : void 0;
    if ((opts == null ? void 0 : opts.expiresIn) && isNaN(expiresIn)) {
      throw new UploadThingError2({
        code: "BAD_REQUEST",
        message: "expiresIn must be a valid time string, for example '1d', '2 days', or a number of seconds."
      });
    }
    if (expiresIn && expiresIn > 86400 * 7) {
      throw new UploadThingError2({
        code: "BAD_REQUEST",
        message: "expiresIn must be less than 7 days (604800 seconds)."
      });
    }
    const json = await this.requestUploadThing(
      "/api/requestFileAccess",
      { fileKey, expiresIn },
      "An unknown error occured while retrieving presigned URLs."
    );
    return json.url;
  }
};

// src/server.ts
var createUploadthing = (opts) => createBuilder(opts);
var INTERNAL_DO_NOT_USE_createRouteHandlerCore = (opts, adapter) => {
  var _a;
  initLogger((_a = opts.config) == null ? void 0 : _a.logLevel);
  incompatibleNodeGuard();
  const requestHandler = buildRequestHandler(
    opts,
    adapter
  );
  const getBuildPerms = buildPermissionsInfoHandler(opts);
  const POST = async (request) => {
    const req = request instanceof Request ? request : request.request;
    const response = await requestHandler({
      nativeRequest: req,
      originalRequest: req,
      event: void 0,
      res: void 0
    });
    if (response instanceof UploadThingError3) {
      return new Response(JSON.stringify(formatError(response, opts.router)), {
        status: getStatusCodeFromError(response),
        headers: {
          "x-uploadthing-version": UPLOADTHING_VERSION
        }
      });
    }
    if (response.status !== 200) {
      return new Response("An unknown error occured", {
        status: 500,
        headers: {
          "x-uploadthing-version": UPLOADTHING_VERSION
        }
      });
    }
    const res = new Response(JSON.stringify(response.body), {
      status: response.status,
      headers: {
        "x-uploadthing-version": UPLOADTHING_VERSION
      }
    });
    res.cleanup = response.cleanup;
    return res;
  };
  const GET = (request) => {
    const _req = request instanceof Request ? request : request.request;
    return new Response(JSON.stringify(getBuildPerms()), {
      status: 200,
      headers: {
        "x-uploadthing-version": UPLOADTHING_VERSION
      }
    });
  };
  return { GET, POST };
};
var createRouteHandler = (opts) => INTERNAL_DO_NOT_USE_createRouteHandlerCore(opts, "server");
var extractRouterConfig = (router) => buildPermissionsInfoHandler({ router })();
var createServerHandler = createRouteHandler;

export {
  UTApi,
  UploadThingError3 as UploadThingError,
  createUploadthing,
  INTERNAL_DO_NOT_USE_createRouteHandlerCore,
  createRouteHandler,
  extractRouterConfig,
  createServerHandler
};
//# sourceMappingURL=chunk-HDSWJLNP.mjs.map