"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/server.ts
var server_exports = {};
__export(server_exports, {
  INTERNAL_DO_NOT_USE_createRouteHandlerCore: () => INTERNAL_DO_NOT_USE_createRouteHandlerCore,
  UTApi: () => UTApi,
  UploadThingError: () => import_shared7.UploadThingError,
  VALID_ACTION_TYPES: () => VALID_ACTION_TYPES,
  createRouteHandler: () => createRouteHandler,
  createServerHandler: () => createServerHandler,
  createUploadthing: () => createUploadthing,
  extractRouterConfig: () => extractRouterConfig,
  unsetMarker: () => unsetMarker
});
module.exports = __toCommonJS(server_exports);
var import_shared7 = require("@uploadthing/shared");

// package.json
var package_default = {
  name: "uploadthing",
  version: "6.3.3",
  engines: {
    node: ">=18.13.0"
  },
  license: "MIT",
  exports: {
    "./package.json": "./package.json",
    "./client": {
      types: "./dist/client.d.ts",
      import: "./dist/client.mjs",
      require: "./dist/client.js"
    },
    "./server": {
      types: "./dist/server.d.ts",
      import: "./dist/server.mjs",
      require: "./dist/server.js"
    },
    "./next": {
      types: "./dist/next.d.ts",
      import: "./dist/next.mjs",
      require: "./dist/next.js"
    },
    "./next-legacy": {
      types: "./dist/next-legacy.d.ts",
      import: "./dist/next-legacy.mjs",
      require: "./dist/next-legacy.js"
    },
    "./express": {
      import: "./dist/express.mjs",
      types: "./dist/express.d.ts",
      require: "./dist/express.js"
    },
    "./tw": {
      types: "./dist/tw.d.ts",
      import: "./dist/tw.mjs",
      require: "./dist/tw.js"
    },
    "./fastify": {
      types: "./dist/fastify.d.ts",
      import: "./dist/fastify.mjs",
      require: "./dist/fastify.js"
    },
    "./h3": {
      types: "./dist/h3.d.ts",
      import: "./dist/h3.mjs",
      require: "./dist/h3.js"
    }
  },
  files: [
    "dist"
  ],
  publishConfig: {
    access: "public"
  },
  typesVersions: {
    "*": {
      client: [
        "dist/client.d.ts"
      ],
      server: [
        "dist/server.d.ts"
      ],
      next: [
        "dist/next.d.ts"
      ],
      "next-legacy": [
        "dist/next-legacy.d.ts"
      ],
      tw: [
        "dist/tw.d.ts"
      ],
      express: [
        "dist/express.d.ts"
      ],
      fastify: [
        "dist/fastify.d.ts"
      ],
      h3: [
        "dist/h3.d.ts"
      ]
    }
  },
  scripts: {
    lint: 'eslint "**/*.{ts,tsx}" --max-warnings 0',
    build: "tsup",
    clean: "git clean -xdf dist node_modules",
    dev: "tsup --watch",
    test: "vitest run",
    "test:watch": "vitest",
    typecheck: "tsc --noEmit"
  },
  dependencies: {
    "@uploadthing/mime-types": "^0.2.2",
    "@uploadthing/shared": "^6.2.1",
    consola: "^3.2.3",
    "std-env": "^3.7.0"
  },
  devDependencies: {
    "@types/express": "^4.17.17",
    "@types/react": "18.2.33",
    "@uploadthing/eslint-config": "0.2.0",
    "@uploadthing/tsconfig": "0.1.0",
    "@uploadthing/tsup-config": "0.1.0",
    eslint: "^8.56.0",
    express: "^4.18.2",
    fastify: "^4.23.2",
    h3: "^1.8.1",
    next: "14.0.1",
    "solid-js": "^1.7.11",
    tailwindcss: "^3.4.1",
    tsup: "6.7.0",
    "type-fest": "^3.11.1",
    typescript: "^5.3.3",
    undici: "^6.5.0",
    vitest: "^1.2.2",
    zod: "^3.22.4"
  },
  eslintConfig: {
    root: true,
    extends: [
      "@uploadthing/eslint-config/base"
    ],
    rules: {
      "no-console": "error",
      "no-restricted-globals": [
        "error",
        {
          name: "fetch",
          message: "fetch should be passed as parameter to support overriding default behaviors"
        },
        {
          name: "process",
          message: "Use `import { process } from 'std-env` instead"
        }
      ]
    }
  }
};

// src/constants.ts
if (!package_default.version)
  throw new Error("no version found in package.json");
var UPLOADTHING_VERSION = package_default.version;

// src/internal/error-formatter.ts
function defaultErrorFormatter(error) {
  return {
    message: error.message
  };
}
function formatError(error, router) {
  var _a;
  const errorFormatter = ((_a = router[Object.keys(router)[0]]) == null ? void 0 : _a._def.errorFormatter) ?? defaultErrorFormatter;
  return errorFormatter(error);
}

// src/internal/handler.ts
var import_std_env3 = require("std-env");
var import_shared3 = require("@uploadthing/shared");

// src/internal/dev-hook.ts
var import_shared2 = require("@uploadthing/shared");

// src/internal/logger.ts
var import_core = require("consola/core");
var import_std_env = require("std-env");
var import_shared = require("@uploadthing/shared");
var colorize = (str, level) => {
  switch (level) {
    case "error":
    case "fatal":
      return `\x1B[41m\x1B[30m${str}\x1B[0m`;
    case "warn":
      return `\x1B[43m\x1B[30m${str}\x1B[0m`;
    case "info":
    case "log":
      return `\x1B[44m\x1B[30m${str}\x1B[0m`;
    case "debug":
      return `\x1B[47m\x1B[30m${str}\x1B[0m`;
    case "trace":
      return `\x1B[47m\x1B[30m${str}\x1B[0m`;
    case "success":
      return `\x1B[42m\x1B[30m${str}\x1B[0m`;
    default:
      return str;
  }
};
var icons = {
  fatal: "\u2A2F",
  error: "\u2A2F",
  warn: "\u26A0\uFE0F",
  info: "\u2139",
  log: "\u2139",
  debug: "\u2699",
  trace: "\u2192",
  success: "\u2713"
};
function formatStack(stack) {
  const cwd = "cwd" in import_std_env.process && typeof import_std_env.process.cwd === "function" ? import_std_env.process.cwd() : "__UnknownCWD__";
  return "  " + stack.split("\n").splice(1).map(
    (l) => l.trim().replace("file://", "").replace(cwd + "/", "")
  ).join("\n  ");
}
function formatArgs(args) {
  const fmtArgs = args.map((arg) => {
    if ((0, import_shared.isObject)(arg) && typeof arg.stack === "string") {
      return arg.message + "\n" + formatStack(arg.stack);
    }
    return arg;
  });
  return fmtArgs.map((arg) => {
    if (typeof arg === "string") {
      return arg;
    }
    try {
      const util = require("util");
      return util.inspect(arg, { depth: 4 });
    } catch {
      return JSON.stringify(arg, null, 4);
    }
  });
}
var logger = (0, import_core.createConsola)({
  reporters: [
    {
      log: (logObj) => {
        const { type, tag, date, args } = logObj;
        const icon = icons[type];
        const logPrefix = colorize(
          ` ${icon} ${tag} ${date.toLocaleTimeString()} `,
          type
        );
        const lines = formatArgs(args).join(" ").split("\n").map((l) => logPrefix + " " + l).join("\n");
        console.log(lines);
      }
    }
  ],
  defaults: {
    tag: "UPLOADTHING"
  }
});
var initLogger = (level) => {
  logger.level = import_core.LogLevels[level ?? "info"];
};

// src/internal/dev-hook.ts
var isValidResponse = (response) => {
  if (!response.ok)
    return false;
  if (response.status >= 400)
    return false;
  if (!response.headers.has("x-uploadthing-version"))
    return false;
  return true;
};
var conditionalDevServer = async (opts) => {
  const fileData = await (0, import_shared2.pollForFileData)(
    {
      url: (0, import_shared2.generateUploadThingURL)(`/api/pollUpload/${opts.fileKey}`),
      apiKey: opts.apiKey,
      sdkVersion: UPLOADTHING_VERSION,
      fetch: opts.fetch
    },
    async (json) => {
      const file = json.fileData;
      let callbackUrl = file.callbackUrl + `?slug=${file.callbackSlug}`;
      if (!callbackUrl.startsWith("http"))
        callbackUrl = "http://" + callbackUrl;
      logger.info("SIMULATING FILE UPLOAD WEBHOOK CALLBACK", callbackUrl);
      const response = await opts.fetch(callbackUrl, {
        method: "POST",
        body: JSON.stringify({
          status: "uploaded",
          metadata: JSON.parse(file.metadata ?? "{}"),
          file: {
            url: `https://utfs.io/f/${encodeURIComponent(opts.fileKey)}`,
            key: opts.fileKey,
            name: file.fileName,
            size: file.fileSize
          }
        }),
        headers: {
          "uploadthing-hook": "callback"
        }
      });
      if (isValidResponse(response)) {
        logger.success(
          "Successfully simulated callback for file",
          opts.fileKey
        );
      } else {
        logger.error(
          "Failed to simulate callback for file. Is your webhook configured correctly?",
          opts.fileKey
        );
      }
      return file;
    }
  );
  if (fileData !== void 0)
    return fileData;
  logger.error(`Failed to simulate callback for file ${opts.fileKey}`);
  throw new import_shared2.UploadThingError({
    code: "UPLOAD_FAILED",
    message: "File took too long to upload"
  });
};

// src/internal/get-full-api-url.ts
var import_std_env2 = require("std-env");
function getFullApiUrl(maybeUrl) {
  const base = (() => {
    var _a;
    if (typeof window !== "undefined")
      return window.location.origin;
    if ((_a = import_std_env2.process.env) == null ? void 0 : _a.VERCEL_URL)
      return `https://${import_std_env2.process.env.VERCEL_URL}`;
    return "http://localhost:3000";
  })();
  try {
    const url = new URL(maybeUrl ?? "/api/uploadthing", base);
    if (url.pathname === "/") {
      url.pathname = "/api/uploadthing";
    }
    return url;
  } catch (err) {
    throw new Error(
      `Failed to parse '${maybeUrl}' as a URL. Make sure it's a valid URL or path`
    );
  }
}

// src/internal/parser.ts
function getParseFn(parser) {
  if (typeof parser.parse === "function") {
    return parser.parse;
  }
  throw new Error("Invalid parser");
}

// src/internal/types.ts
var unsetMarker = "unsetMarker";
var VALID_ACTION_TYPES = [
  "upload",
  "failure",
  "multipart-complete"
];

// src/internal/handler.ts
var createUTFetch = (apiKey, fetch, fePackage, beAdapter) => {
  return async (endpoint, payload) => {
    const response = await fetch((0, import_shared3.generateUploadThingURL)(endpoint), {
      method: "POST",
      body: JSON.stringify(payload),
      headers: {
        "Content-Type": "application/json",
        "x-uploadthing-api-key": apiKey,
        "x-uploadthing-version": UPLOADTHING_VERSION,
        "x-uploadthing-fe-package": fePackage,
        "x-uploadthing-be-adapter": beAdapter
      }
    });
    return response;
  };
};
var fileCountLimitHit = (files, routeConfig) => {
  var _a;
  const counts = {};
  files.forEach((file) => {
    const type = (0, import_shared3.getTypeFromFileName)(file.name, (0, import_shared3.objectKeys)(routeConfig));
    if (!counts[type]) {
      counts[type] = 1;
    } else {
      counts[type] += 1;
    }
  });
  for (const _key in counts) {
    const key = _key;
    const count = counts[key];
    const limit = (_a = routeConfig[key]) == null ? void 0 : _a.maxFileCount;
    if (!limit) {
      logger.error(routeConfig, key);
      throw new import_shared3.UploadThingError({
        code: "BAD_REQUEST",
        message: "Invalid config during file count",
        cause: `Expected route config to have a maxFileCount for key ${key} but none was found.`
      });
    }
    if (count > limit) {
      return { limitHit: true, type: key, limit, count };
    }
  }
  return { limitHit: false };
};
var buildRequestHandler = (opts, adapter) => {
  return async (input) => {
    var _a, _b;
    const isDev = ((_a = opts.config) == null ? void 0 : _a.isDev) ?? import_std_env3.isDevelopment;
    const fetch = ((_b = opts.config) == null ? void 0 : _b.fetch) ?? globalThis.fetch;
    if (isDev) {
      logger.info("UploadThing dev server is now running!");
    }
    const { router, config } = opts;
    const preferredOrEnvSecret = (config == null ? void 0 : config.uploadthingSecret) ?? import_std_env3.process.env.UPLOADTHING_SECRET;
    const req = input.nativeRequest;
    const url = new URL(req.url);
    const params = url.searchParams;
    const uploadthingHook = req.headers.get("uploadthing-hook") ?? void 0;
    const slug = params.get("slug") ?? void 0;
    const actionType = params.get("actionType") ?? void 0;
    const utFrontendPackage = req.headers.get("x-uploadthing-package") ?? "unknown";
    if (!slug) {
      logger.error("No slug provided in params:", params);
      return new import_shared3.UploadThingError({
        code: "BAD_REQUEST",
        message: "No slug provided in params"
      });
    }
    if (slug && typeof slug !== "string") {
      const msg = `Expected slug to be of type 'string', got '${typeof slug}'`;
      logger.error(msg);
      return new import_shared3.UploadThingError({
        code: "BAD_REQUEST",
        message: "`slug` must be a string",
        cause: msg
      });
    }
    if (actionType && typeof actionType !== "string") {
      const msg = `Expected actionType to be of type 'string', got '${typeof actionType}'`;
      logger.error(msg);
      return new import_shared3.UploadThingError({
        code: "BAD_REQUEST",
        message: "`actionType` must be a string",
        cause: msg
      });
    }
    if (uploadthingHook && typeof uploadthingHook !== "string") {
      const msg = `Expected uploadthingHook to be of type 'string', got '${typeof uploadthingHook}'`;
      return new import_shared3.UploadThingError({
        code: "BAD_REQUEST",
        message: "`uploadthingHook` must be a string",
        cause: msg
      });
    }
    if (!preferredOrEnvSecret) {
      const msg = `No secret provided, please set UPLOADTHING_SECRET in your env file or in the config`;
      logger.error(msg);
      return new import_shared3.UploadThingError({
        code: "MISSING_ENV",
        message: `No secret provided`,
        cause: msg
      });
    }
    if (!preferredOrEnvSecret.startsWith("sk_")) {
      const msg = `Invalid secret provided, UPLOADTHING_SECRET must start with 'sk_'`;
      logger.error(msg);
      return new import_shared3.UploadThingError({
        code: "MISSING_ENV",
        message: "Invalid API key. API keys must start with 'sk_'.",
        cause: msg
      });
    }
    if (utFrontendPackage && typeof utFrontendPackage !== "string") {
      const msg = `Expected x-uploadthing-package to be of type 'string', got '${typeof utFrontendPackage}'`;
      logger.error(msg);
      return new import_shared3.UploadThingError({
        code: "BAD_REQUEST",
        message: "`x-uploadthing-package` must be a string. eg. '@uploadthing/react'",
        cause: msg
      });
    }
    const uploadable = router[slug];
    if (!uploadable) {
      const msg = `No file route found for slug ${slug}`;
      logger.error(msg);
      return new import_shared3.UploadThingError({
        code: "NOT_FOUND",
        message: msg
      });
    }
    const utFetch = createUTFetch(
      preferredOrEnvSecret,
      fetch,
      utFrontendPackage,
      adapter
    );
    logger.debug("All request input is valid", {
      slug,
      actionType,
      uploadthingHook
    });
    if (uploadthingHook === "callback") {
      const maybeReqBody = await (0, import_shared3.safeParseJSON)(req);
      logger.debug("Handling callback request with input:", maybeReqBody);
      if (maybeReqBody instanceof Error) {
        logger.error("Invalid request body", maybeReqBody);
        return new import_shared3.UploadThingError({
          code: "BAD_REQUEST",
          message: "Invalid request body",
          cause: maybeReqBody
        });
      }
      const resolverArgs = {
        file: maybeReqBody.file,
        metadata: maybeReqBody.metadata
      };
      logger.debug(
        "Running 'onUploadComplete' callback with input:",
        resolverArgs
      );
      const res = await uploadable.resolver(resolverArgs);
      const payload = {
        fileKey: maybeReqBody.file.key,
        callbackData: res ?? null
      };
      logger.debug(
        "'onUploadComplete' callback finished. Sending response to UploadThing:",
        payload
      );
      const callbackResponse = await utFetch("/api/serverCallback", payload);
      logger.debug(
        "UploadThing responded with status:",
        callbackResponse.status
      );
      return { status: 200 };
    }
    if (!actionType || !VALID_ACTION_TYPES.includes(actionType)) {
      const msg = `Expected ${VALID_ACTION_TYPES.map((x) => `"${x}"`).join(", ").replace(/,(?!.*,)/, " or")} but got "${actionType}"`;
      logger.error("Invalid action type.", msg);
      return new import_shared3.UploadThingError({
        code: "BAD_REQUEST",
        cause: `Invalid action type ${actionType}`,
        message: msg
      });
    }
    switch (actionType) {
      case "upload": {
        const maybeInput = await (0, import_shared3.safeParseJSON)(req);
        if (maybeInput instanceof Error) {
          logger.error("Invalid request body", maybeInput);
          return new import_shared3.UploadThingError({
            code: "BAD_REQUEST",
            message: "Invalid request body",
            cause: maybeInput
          });
        }
        logger.debug("Handling upload request with input:", maybeInput);
        const { files, input: userInput } = maybeInput;
        let parsedInput = {};
        try {
          logger.debug("Parsing input");
          const inputParser = uploadable._def.inputParser;
          parsedInput = await getParseFn(inputParser)(userInput);
          logger.debug("Input parsed successfully", parsedInput);
        } catch (error) {
          logger.error("An error occured trying to parse input", error);
          return new import_shared3.UploadThingError({
            code: "BAD_REQUEST",
            message: "Invalid input.",
            cause: error
          });
        }
        let metadata = {};
        try {
          logger.debug("Running middleware");
          metadata = await uploadable._def.middleware({
            req: input.originalRequest,
            res: input.res,
            event: input.event,
            input: parsedInput,
            files
          });
          logger.debug("Middleware finished successfully with:", metadata);
        } catch (error) {
          logger.error("An error occured in your middleware function", error);
          if (error instanceof import_shared3.UploadThingError)
            return error;
          return new import_shared3.UploadThingError({
            code: "INTERNAL_SERVER_ERROR",
            message: "Failed to run middleware.",
            cause: error
          });
        }
        if (!Array.isArray(files) || !files.every(
          (f) => (0, import_shared3.isObject)(f) && typeof f.name === "string" && typeof f.size === "number"
        )) {
          const msg = `Expected files to be of type '{name:string, size:number}[]', got '${JSON.stringify(
            files
          )}'`;
          logger.error(msg);
          return new import_shared3.UploadThingError({
            code: "BAD_REQUEST",
            message: "Files must be an array of objects with name and size",
            cause: msg
          });
        }
        let parsedConfig;
        try {
          logger.debug("Parsing route config", uploadable._def.routerConfig);
          parsedConfig = (0, import_shared3.fillInputRouteConfig)(
            uploadable._def.routerConfig
          );
          logger.debug("Route config parsed successfully", parsedConfig);
        } catch (error) {
          logger.error("Invalid route config", error);
          return new import_shared3.UploadThingError({
            code: "BAD_REQUEST",
            message: "Invalid config.",
            cause: error
          });
        }
        try {
          logger.debug("Checking file count limit", files);
          const { limitHit, count, limit, type } = fileCountLimitHit(
            files,
            parsedConfig
          );
          if (limitHit) {
            const msg = `You uploaded ${count} files of type '${type}', but the limit for that type is ${limit}`;
            logger.error(msg);
            return new import_shared3.UploadThingError({
              code: "BAD_REQUEST",
              message: "File limit exceeded",
              cause: msg
            });
          }
          logger.debug("File count limit check passed");
        } catch (error) {
          logger.error("Invalid route config", error);
          return new import_shared3.UploadThingError({
            code: "BAD_REQUEST",
            message: "Invalid config.",
            cause: error
          });
        }
        const callbackUrl = resolveCallbackUrl({ config, req, url, isDev });
        logger.debug(
          "Retrieving presigned URLs from UploadThing. Callback URL is:",
          callbackUrl.href
        );
        const uploadthingApiResponse = await utFetch("/api/prepareUpload", {
          files,
          routeConfig: parsedConfig,
          metadata,
          callbackUrl: callbackUrl.origin + callbackUrl.pathname,
          callbackSlug: slug
        });
        const parsedResponse = await (0, import_shared3.safeParseJSON)(
          uploadthingApiResponse
        );
        if (!uploadthingApiResponse.ok || parsedResponse instanceof Error) {
          logger.error("Unable to get presigned URLs", parsedResponse);
          return new import_shared3.UploadThingError({
            code: "URL_GENERATION_FAILED",
            message: "Unable to get presigned urls",
            cause: parsedResponse
          });
        }
        logger.debug("UploadThing responded with:", parsedResponse);
        logger.debug("Sending presigned URLs to client");
        let promise = void 0;
        if (isDev) {
          promise = Promise.all(
            parsedResponse.map(
              (file) => conditionalDevServer({
                fileKey: file.key,
                apiKey: preferredOrEnvSecret,
                fetch
              }).catch((error) => {
                logger.error("Err", error);
              })
            )
          );
        }
        return {
          cleanup: promise,
          body: parsedResponse.map((x) => ({
            ...x,
            pollingUrl: (0, import_shared3.generateUploadThingURL)(`/api/serverCallback`)
          })),
          status: 200
        };
      }
      case "multipart-complete": {
        const maybeReqBody = await (0, import_shared3.safeParseJSON)(req);
        if (maybeReqBody instanceof Error) {
          logger.error("Invalid request body", maybeReqBody);
          return new import_shared3.UploadThingError({
            code: "BAD_REQUEST",
            message: "Invalid request body",
            cause: maybeReqBody
          });
        }
        logger.debug(
          "Handling multipart-complete request with input:",
          maybeReqBody
        );
        logger.debug("Notifying UploadThing that multipart upload is complete");
        const completeRes = await utFetch("/api/completeMultipart", {
          fileKey: maybeReqBody.fileKey,
          uploadId: maybeReqBody.uploadId,
          etags: maybeReqBody.etags
        });
        if (!completeRes.ok) {
          logger.error(
            "Failed to notify UploadThing that multipart upload is complete"
          );
          return new import_shared3.UploadThingError({
            code: "UPLOAD_FAILED",
            message: "Failed to complete multipart upload",
            cause: completeRes
          });
        }
        logger.debug("UploadThing responded with:", completeRes.status);
        return { status: 200 };
      }
      case "failure": {
        const maybeReqBody = await (0, import_shared3.safeParseJSON)(req);
        if (maybeReqBody instanceof Error) {
          logger.error("Invalid request body", maybeReqBody);
          return new import_shared3.UploadThingError({
            code: "BAD_REQUEST",
            message: "Invalid request body",
            cause: maybeReqBody
          });
        }
        const { fileKey, uploadId } = maybeReqBody;
        logger.debug("Handling failure request with input:", maybeReqBody);
        logger.debug("Notifying UploadThing that upload failed");
        const uploadthingApiResponse = await utFetch("/api/failureCallback", {
          fileKey,
          uploadId
        });
        if (!uploadthingApiResponse.ok) {
          const parsedResponse = await (0, import_shared3.safeParseJSON)(
            uploadthingApiResponse
          );
          logger.error("Failed to mark upload as failed", parsedResponse);
          return new import_shared3.UploadThingError({
            code: "INTERNAL_SERVER_ERROR",
            message: "Unable to mark upload as failed",
            cause: parsedResponse
          });
        }
        logger.debug("UploadThing responded with:", uploadthingApiResponse);
        logger.debug("Running 'onUploadError' callback");
        try {
          uploadable._def.onUploadError({
            error: new import_shared3.UploadThingError({
              code: "UPLOAD_FAILED",
              message: `Upload failed for ${fileKey}`
            }),
            fileKey
          });
        } catch (error) {
          logger.error(
            "Failed to run onUploadError callback. You probably shouldn't be throwing errors in your callback.",
            error
          );
          return new import_shared3.UploadThingError({
            code: "INTERNAL_SERVER_ERROR",
            message: "Failed to run onUploadError callback",
            cause: error
          });
        }
        return { status: 200 };
      }
      default: {
        return new import_shared3.UploadThingError({
          code: "BAD_REQUEST",
          message: `Invalid action type`
        });
      }
    }
  };
};
function resolveCallbackUrl(opts) {
  var _a;
  let callbackUrl = opts.url;
  if ((_a = opts.config) == null ? void 0 : _a.callbackUrl) {
    callbackUrl = getFullApiUrl(opts.config.callbackUrl);
  } else if (import_std_env3.process.env.UPLOADTHING_URL) {
    callbackUrl = getFullApiUrl(import_std_env3.process.env.UPLOADTHING_URL);
  }
  if (opts.isDev || !callbackUrl.host.includes("localhost")) {
    return callbackUrl;
  }
  const headers = opts.req.headers;
  let parsedFromHeaders = headers.get("origin") ?? headers.get("referer") ?? headers.get("host") ?? headers.get("x-forwarded-host");
  if (parsedFromHeaders && !parsedFromHeaders.includes("http")) {
    parsedFromHeaders = (headers.get("x-forwarded-proto") ?? "https") + "://" + parsedFromHeaders;
  }
  if (!parsedFromHeaders || parsedFromHeaders.includes("localhost")) {
    logger.warn(
      "You are using a localhost callback url in production which is not supported.",
      "Read more and learn how to fix it here: https://docs.uploadthing.com/faq#my-callback-runs-in-development-but-not-in-production"
    );
    return callbackUrl;
  }
  return getFullApiUrl(parsedFromHeaders);
}
var buildPermissionsInfoHandler = (opts) => {
  return () => {
    const r = opts.router;
    const permissions = Object.keys(r).map((k) => {
      const route = r[k];
      const config = (0, import_shared3.fillInputRouteConfig)(route._def.routerConfig);
      return {
        slug: k,
        config
      };
    });
    return permissions;
  };
};

// src/internal/incompat-node-guard.ts
var import_std_env4 = require("std-env");
function incompatibleNodeGuard() {
  var _a, _b, _c, _d, _e, _f;
  if (typeof import_std_env4.process === "undefined")
    return;
  let major;
  let minor;
  const maybeNodeVersion = (_b = (_a = import_std_env4.process.versions) == null ? void 0 : _a.node) == null ? void 0 : _b.split(".");
  if (maybeNodeVersion) {
    [major, minor] = maybeNodeVersion.map((v) => parseInt(v, 10));
  }
  const maybeNodePath = (_c = import_std_env4.process.env) == null ? void 0 : _c.NODE;
  if (!major && maybeNodePath) {
    const nodeVersion = (_d = /v(\d+)\.(\d+)\.(\d+)/.exec(maybeNodePath)) == null ? void 0 : _d[0];
    if (nodeVersion) {
      [major, minor] = nodeVersion.substring(1).split(".").map((v) => parseInt(v, 10));
    }
  }
  if (!major || !minor)
    return;
  if (major > 18)
    return;
  if (major === 18 && minor >= 13)
    return;
  logger.fatal(
    `YOU ARE USING A LEGACY (${major}.${minor}) NODE VERSION WHICH ISN'T OFFICIALLY SUPPORTED. PLEASE UPGRADE TO NODE ^18.13.`
  );
  (_f = (_e = import_std_env4.process).exit) == null ? void 0 : _f.call(_e, 1);
}

// src/internal/upload-builder.ts
function internalCreateBuilder(initDef = {}) {
  const _def = {
    // Default router config
    routerConfig: {
      image: {
        maxFileSize: "4MB"
      }
    },
    inputParser: { parse: () => ({}), _input: {}, _output: {} },
    middleware: () => ({}),
    onUploadError: () => ({}),
    errorFormatter: initDef.errorFormatter ?? defaultErrorFormatter,
    // Overload with properties passed in
    ...initDef
  };
  return {
    input(userParser) {
      return internalCreateBuilder({
        ..._def,
        inputParser: userParser
      });
    },
    middleware(userMiddleware) {
      return internalCreateBuilder({
        ..._def,
        middleware: userMiddleware
      });
    },
    onUploadComplete(userUploadComplete) {
      return {
        _def,
        resolver: userUploadComplete
      };
    },
    onUploadError(userOnUploadError) {
      return internalCreateBuilder({
        ..._def,
        onUploadError: userOnUploadError
      });
    }
  };
}
function createBuilder(opts) {
  return (input) => {
    return internalCreateBuilder({
      routerConfig: input,
      ...opts
    });
  };
}

// src/sdk/index.ts
var import_std_env6 = require("std-env");
var import_shared6 = require("@uploadthing/shared");

// src/sdk/utils.ts
var import_std_env5 = require("std-env");
var import_shared5 = require("@uploadthing/shared");

// src/internal/multi-part.ts
var import_shared4 = require("@uploadthing/shared");

// src/internal/s3-error-parser.ts
var maybeParseResponseXML = (maybeXml) => {
  const codeMatch = maybeXml.match(/<Code>(.*?)<\/Code>/s);
  const messageMatch = maybeXml.match(/<Message>(.*?)<\/Message>/s);
  const code = codeMatch == null ? void 0 : codeMatch[1];
  const message = messageMatch == null ? void 0 : messageMatch[1];
  if (!code || !message)
    return null;
  return { code: s3CodeToUploadThingCode[code] ?? DEFAULT_ERROR_CODE, message };
};
var DEFAULT_ERROR_CODE = "UPLOAD_FAILED";
var s3CodeToUploadThingCode = {
  AccessDenied: "FORBIDDEN",
  // 403 Forbidden
  EntityTooSmall: "TOO_SMALL",
  // 400 Bad Request
  EntityTooLarge: "TOO_LARGE",
  // 400 Bad Request
  ExpiredToken: "FORBIDDEN",
  // 400 Bad Request
  IncorrectNumberOfFilesInPostRequest: "TOO_MANY_FILES",
  // 400 Bad Request
  InternalError: "INTERNAL_SERVER_ERROR",
  // 500 Internal Server Error
  KeyTooLongError: "KEY_TOO_LONG",
  // 400 Bad Request
  MaxMessageLengthExceeded: "TOO_LARGE"
  // 400 Bad Request
};

// src/internal/multi-part.ts
async function uploadPart(opts, retryCount = 0) {
  const s3Res = await opts.fetch(opts.url, {
    method: "PUT",
    body: opts.chunk,
    headers: {
      "Content-Type": opts.contentType,
      "Content-Disposition": [
        opts.contentDisposition,
        `filename="${encodeURI(opts.fileName)}"`,
        `filename*=UTF-8''${encodeURI(opts.fileName)}`
      ].join("; ")
    }
  });
  if (s3Res.ok) {
    const etag = s3Res.headers.get("Etag");
    if (!etag) {
      throw new import_shared4.UploadThingError({
        code: "UPLOAD_FAILED",
        message: "Missing Etag header from uploaded part"
      });
    }
    return etag.replace(/"/g, "");
  }
  if (retryCount < opts.maxRetries) {
    const delay = 2 ** retryCount * 1e3;
    await new Promise((r) => setTimeout(r, delay));
    return uploadPart(opts, retryCount++);
  }
  await opts.fetch((0, import_shared4.generateUploadThingURL)("/api/failureCallback"), {
    method: "POST",
    body: JSON.stringify({
      fileKey: opts.key
    }),
    headers: opts.utRequestHeaders
  });
  const text = await s3Res.text();
  const parsed = maybeParseResponseXML(text);
  if (parsed == null ? void 0 : parsed.message) {
    throw new import_shared4.UploadThingError({
      code: "UPLOAD_FAILED",
      message: parsed.message
    });
  }
  throw new import_shared4.UploadThingError({
    code: "UPLOAD_FAILED",
    message: "Failed to upload file to storage provider",
    cause: s3Res
  });
}

// src/sdk/utils.ts
function guardServerOnly() {
  if (typeof window !== "undefined") {
    throw new import_shared5.UploadThingError({
      code: "INTERNAL_SERVER_ERROR",
      message: "The `utapi` can only be used on the server."
    });
  }
}
function getApiKeyOrThrow(apiKey) {
  if (apiKey)
    return apiKey;
  if (import_std_env5.process.env.UPLOADTHING_SECRET)
    return import_std_env5.process.env.UPLOADTHING_SECRET;
  throw new import_shared5.UploadThingError({
    code: "MISSING_ENV",
    message: "Missing `UPLOADTHING_SECRET` env variable."
  });
}
var uploadFilesInternal = async (data, opts) => {
  const fileData = data.files.map((file) => ({
    name: file.name ?? "unnamed-blob",
    type: file.type,
    size: file.size
  }));
  logger.debug("Getting presigned URLs for files", fileData);
  const res = await opts.fetch((0, import_shared5.generateUploadThingURL)("/api/uploadFiles"), {
    method: "POST",
    headers: opts.utRequestHeaders,
    cache: "no-store",
    body: JSON.stringify({
      files: fileData,
      metadata: data.metadata,
      contentDisposition: data.contentDisposition,
      acl: data.acl
    })
  });
  if (!res.ok) {
    const error = await import_shared5.UploadThingError.fromResponse(res);
    logger.debug("Failed getting presigned URLs:", error);
    throw error;
  }
  if (!res.ok) {
    const error = await import_shared5.UploadThingError.fromResponse(res);
    logger.debug("Failed getting presigned URLs:", error);
    throw error;
  }
  const json = await res.json();
  logger.debug("Got presigned URLs:", json.data);
  logger.debug("Starting uploads...");
  const uploads = await Promise.allSettled(
    data.files.map(async (file, i) => {
      const { presignedUrls, key, fileUrl, uploadId, chunkSize } = json.data[i];
      if (!presignedUrls || !Array.isArray(presignedUrls)) {
        logger.error(
          "Failed to generate presigned URL for file:",
          file,
          json.data[i]
        );
        throw new import_shared5.UploadThingError({
          code: "URL_GENERATION_FAILED",
          message: "Failed to generate presigned URL",
          cause: JSON.stringify(json.data[i])
        });
      }
      logger.debug(
        "Uploading file",
        file.name,
        "with",
        presignedUrls.length,
        "chunks of size",
        chunkSize,
        "bytes each"
      );
      const etags = await Promise.all(
        presignedUrls.map(async (url, index) => {
          const offset = chunkSize * index;
          const end = Math.min(offset + chunkSize, file.size);
          const chunk = file.slice(offset, end);
          const etag = await uploadPart({
            fetch: opts.fetch,
            url,
            chunk,
            contentDisposition: data.contentDisposition,
            contentType: file.type,
            fileName: file.name,
            maxRetries: 10,
            key,
            utRequestHeaders: opts.utRequestHeaders
          });
          logger.debug("Part", index + 1, "uploaded successfully:", etag);
          return { tag: etag, partNumber: index + 1 };
        })
      );
      logger.debug(
        "File",
        file.name,
        "uploaded successfully. Notifying UploadThing to complete multipart upload."
      );
      const completionRes = await opts.fetch(
        (0, import_shared5.generateUploadThingURL)("/api/completeMultipart"),
        {
          method: "POST",
          body: JSON.stringify({
            fileKey: key,
            uploadId,
            etags
          }),
          headers: opts.utRequestHeaders
        }
      );
      logger.debug("UploadThing responsed with status:", completionRes.status);
      logger.debug("Polling for file data...");
      await (0, import_shared5.pollForFileData)({
        url: (0, import_shared5.generateUploadThingURL)(`/api/pollUpload/${key}`),
        apiKey: opts.utRequestHeaders["x-uploadthing-api-key"],
        sdkVersion: UPLOADTHING_VERSION,
        fetch: opts.fetch
      });
      logger.debug("Polling complete.");
      return {
        key,
        url: fileUrl,
        name: file.name,
        size: file.size
      };
    })
  );
  logger.debug("All uploads complete, aggregating results...");
  return uploads.map((upload) => {
    if (upload.status === "fulfilled") {
      const data2 = upload.value;
      return { data: data2, error: null };
    }
    const reason = upload.reason;
    const error = import_shared5.UploadThingError.toObject(reason);
    return { data: null, error };
  });
};
function parseTimeToSeconds(time) {
  const match = time.toString().split(/(\d+)/).filter(Boolean);
  const num = Number(match[0]);
  const unit = (match[1] ?? "s").trim().slice(0, 1);
  const multiplier = {
    s: 1,
    m: 60,
    h: 3600,
    d: 86400
  }[unit];
  return num * multiplier;
}

// src/sdk/index.ts
var UTApi = class {
  constructor(opts) {
    /** @deprecated Use {@link renameFiles} instead. */
    // eslint-disable-next-line @typescript-eslint/unbound-method
    this.renameFile = this.renameFiles;
    var _a;
    this.fetch = (opts == null ? void 0 : opts.fetch) ?? globalThis.fetch;
    this.apiKey = (opts == null ? void 0 : opts.apiKey) ?? import_std_env6.process.env.UPLOADTHING_SECRET;
    this.defaultHeaders = {
      "Content-Type": "application/json",
      "x-uploadthing-api-key": this.apiKey,
      "x-uploadthing-version": UPLOADTHING_VERSION,
      "x-uploadthing-be-adapter": "server-sdk"
    };
    initLogger(opts == null ? void 0 : opts.logLevel);
    guardServerOnly();
    getApiKeyOrThrow(this.apiKey);
    if (!((_a = this.apiKey) == null ? void 0 : _a.startsWith("sk_"))) {
      throw new import_shared6.UploadThingError({
        code: "MISSING_ENV",
        message: "Invalid API key. API keys must start with `sk_`."
      });
    }
    incompatibleNodeGuard();
  }
  async requestUploadThing(pathname, body, fallbackErrorMessage) {
    const url = (0, import_shared6.generateUploadThingURL)(pathname);
    logger.debug("Requesting UploadThing:", {
      url,
      body,
      headers: this.defaultHeaders
    });
    const res = await this.fetch(url, {
      method: "POST",
      cache: "no-store",
      headers: this.defaultHeaders,
      body: JSON.stringify(body)
    });
    logger.debug("UploadThing responsed with status:", res.status);
    const json = await res.json();
    if (!res.ok || "error" in json) {
      logger.error("Error:", json);
      throw new import_shared6.UploadThingError({
        code: "INTERNAL_SERVER_ERROR",
        message: "error" in json && typeof json.error === "string" ? json.error : fallbackErrorMessage
      });
    }
    logger.debug("UploadThing response:", json);
    return json;
  }
  /**
   * Upload files to UploadThing storage.
   *
   * @example
   * await uploadFiles(new File(["foo"], "foo.txt"));
   *
   * @example
   * await uploadFiles([
   *   new File(["foo"], "foo.txt"),
   *   new File(["bar"], "bar.txt"),
   * ]);
   */
  async uploadFiles(files, opts) {
    guardServerOnly();
    const filesToUpload = Array.isArray(files) ? files : [files];
    logger.debug("Uploading files:", filesToUpload);
    const uploads = await uploadFilesInternal(
      {
        files: filesToUpload,
        metadata: (opts == null ? void 0 : opts.metadata) ?? {},
        contentDisposition: (opts == null ? void 0 : opts.contentDisposition) ?? "inline",
        acl: opts == null ? void 0 : opts.acl
      },
      {
        fetch: this.fetch,
        utRequestHeaders: this.defaultHeaders
      }
    );
    const uploadFileResponse = Array.isArray(files) ? uploads : uploads[0];
    logger.debug("Finished uploading:", uploadFileResponse);
    return uploadFileResponse;
  }
  /**
   * @param {string} url The URL of the file to upload
   * @param {Json} metadata JSON-parseable metadata to attach to the uploaded file(s)
   *
   * @example
   * await uploadFileFromUrl("https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg");
   *
   * @example
   * await uploadFileFromUrl([
   *   "https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg",
   *   "https://uploadthing.com/f/1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg"
   * ])
   */
  async uploadFilesFromUrl(urls, opts) {
    guardServerOnly();
    const fileUrls = Array.isArray(urls) ? urls : [urls];
    const formData = new FormData();
    formData.append("metadata", JSON.stringify((opts == null ? void 0 : opts.metadata) ?? {}));
    const filesToUpload = await Promise.all(
      fileUrls.map(async (url) => {
        if (typeof url === "string")
          url = new URL(url);
        const filename = url.pathname.split("/").pop() ?? "unknown-filename";
        logger.debug("Downloading file:", url);
        const fileResponse = await this.fetch(url);
        if (!fileResponse.ok) {
          throw new import_shared6.UploadThingError({
            code: "BAD_REQUEST",
            message: "Failed to download requested file.",
            cause: fileResponse
          });
        }
        logger.debug("Finished downloading file. Reading blob...");
        const blob = await fileResponse.blob();
        logger.debug("Finished reading blob.");
        return Object.assign(blob, { name: filename });
      })
    );
    logger.debug("All files downloaded, uploading...");
    const uploads = await uploadFilesInternal(
      {
        files: filesToUpload,
        metadata: (opts == null ? void 0 : opts.metadata) ?? {},
        contentDisposition: (opts == null ? void 0 : opts.contentDisposition) ?? "inline",
        acl: opts == null ? void 0 : opts.acl
      },
      {
        fetch: this.fetch,
        utRequestHeaders: this.defaultHeaders
      }
    );
    const uploadFileResponse = Array.isArray(urls) ? uploads : uploads[0];
    logger.debug("Finished uploading:", uploadFileResponse);
    return uploadFileResponse;
  }
  /**
   * Request to delete files from UploadThing storage.
   * @param {string | string[]} fileKeys
   *
   * @example
   * await deleteFiles("2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg");
   *
   * @example
   * await deleteFiles(["2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg","1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg"])
   */
  async deleteFiles(fileKeys) {
    guardServerOnly();
    if (!Array.isArray(fileKeys))
      fileKeys = [fileKeys];
    return this.requestUploadThing(
      "/api/deleteFile",
      { fileKeys },
      "An unknown error occured while deleting files."
    );
  }
  /**
   * Request file URLs from UploadThing storage.
   * @param {string | string[]} fileKeys
   *
   * @example
   * const data = await getFileUrls("2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg");
   * console.log(data); // [{key: "2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg", url: "https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg"}]
   *
   * @example
   * const data = await getFileUrls(["2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg","1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg"])
   * console.log(data) // [{key: "2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg", url: "https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg" },{key: "1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg", url: "https://uploadthing.com/f/1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg"}]
   */
  async getFileUrls(fileKeys) {
    guardServerOnly();
    if (!Array.isArray(fileKeys))
      fileKeys = [fileKeys];
    const json = await this.requestUploadThing(
      "/api/getFileUrl",
      { fileKeys },
      "An unknown error occured while retrieving file URLs."
    );
    return json.data;
  }
  /**
   * Request file list from UploadThing storage.
   * @param {object} opts
   * @param {number} opts.limit The maximum number of files to return
   * @param {number} opts.offset The number of files to skip
   *
   * @example
   * const data = await listFiles({ limit: 1 });
   * console.log(data); // { key: "2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg", id: "2e0fdb64-9957-4262-8e45-f372ba903ac8" }
   */
  async listFiles(opts) {
    guardServerOnly();
    const json = await this.requestUploadThing("/api/listFiles", opts, "An unknown error occured while listing files.");
    return json.files;
  }
  async renameFiles(updates) {
    guardServerOnly();
    if (!Array.isArray(updates))
      updates = [updates];
    return this.requestUploadThing(
      "/api/renameFiles",
      { updates },
      "An unknown error occured while renaming files."
    );
  }
  async getUsageInfo() {
    guardServerOnly();
    return this.requestUploadThing(
      "/api/getUsageInfo",
      {},
      "An unknown error occured while getting usage info."
    );
  }
  /** Request a presigned url for a private file(s) */
  async getSignedURL(fileKey, opts) {
    guardServerOnly();
    const expiresIn = (opts == null ? void 0 : opts.expiresIn) ? parseTimeToSeconds(opts.expiresIn) : void 0;
    if ((opts == null ? void 0 : opts.expiresIn) && isNaN(expiresIn)) {
      throw new import_shared6.UploadThingError({
        code: "BAD_REQUEST",
        message: "expiresIn must be a valid time string, for example '1d', '2 days', or a number of seconds."
      });
    }
    if (expiresIn && expiresIn > 86400 * 7) {
      throw new import_shared6.UploadThingError({
        code: "BAD_REQUEST",
        message: "expiresIn must be less than 7 days (604800 seconds)."
      });
    }
    const json = await this.requestUploadThing(
      "/api/requestFileAccess",
      { fileKey, expiresIn },
      "An unknown error occured while retrieving presigned URLs."
    );
    return json.url;
  }
};

// src/server.ts
var createUploadthing = (opts) => createBuilder(opts);
var INTERNAL_DO_NOT_USE_createRouteHandlerCore = (opts, adapter) => {
  var _a;
  initLogger((_a = opts.config) == null ? void 0 : _a.logLevel);
  incompatibleNodeGuard();
  const requestHandler = buildRequestHandler(
    opts,
    adapter
  );
  const getBuildPerms = buildPermissionsInfoHandler(opts);
  const POST = async (request) => {
    const req = request instanceof Request ? request : request.request;
    const response = await requestHandler({
      nativeRequest: req,
      originalRequest: req,
      event: void 0,
      res: void 0
    });
    if (response instanceof import_shared7.UploadThingError) {
      return new Response(JSON.stringify(formatError(response, opts.router)), {
        status: (0, import_shared7.getStatusCodeFromError)(response),
        headers: {
          "x-uploadthing-version": UPLOADTHING_VERSION
        }
      });
    }
    if (response.status !== 200) {
      return new Response("An unknown error occured", {
        status: 500,
        headers: {
          "x-uploadthing-version": UPLOADTHING_VERSION
        }
      });
    }
    const res = new Response(JSON.stringify(response.body), {
      status: response.status,
      headers: {
        "x-uploadthing-version": UPLOADTHING_VERSION
      }
    });
    res.cleanup = response.cleanup;
    return res;
  };
  const GET = (request) => {
    const _req = request instanceof Request ? request : request.request;
    return new Response(JSON.stringify(getBuildPerms()), {
      status: 200,
      headers: {
        "x-uploadthing-version": UPLOADTHING_VERSION
      }
    });
  };
  return { GET, POST };
};
var createRouteHandler = (opts) => INTERNAL_DO_NOT_USE_createRouteHandlerCore(opts, "server");
var extractRouterConfig = (router) => buildPermissionsInfoHandler({ router })();
var createServerHandler = createRouteHandler;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  INTERNAL_DO_NOT_USE_createRouteHandlerCore,
  UTApi,
  UploadThingError,
  VALID_ACTION_TYPES,
  createRouteHandler,
  createServerHandler,
  createUploadthing,
  extractRouterConfig,
  unsetMarker
});
//# sourceMappingURL=server.js.map